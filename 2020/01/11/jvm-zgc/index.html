<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM ZGC 简介 | NeroBlackstone&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.efb332ed.css" as="style"><link rel="preload" href="/assets/js/app.ec2d5af2.js" as="script"><link rel="preload" href="/assets/js/3.e9bff2d3.js" as="script"><link rel="preload" href="/assets/js/7.df8bc73d.js" as="script"><link rel="prefetch" href="/assets/js/10.7e730691.js"><link rel="prefetch" href="/assets/js/11.0a8c3a3b.js"><link rel="prefetch" href="/assets/js/12.e41009b6.js"><link rel="prefetch" href="/assets/js/13.615800ed.js"><link rel="prefetch" href="/assets/js/14.9ff2a10b.js"><link rel="prefetch" href="/assets/js/15.c0f3d8e0.js"><link rel="prefetch" href="/assets/js/16.267a81c0.js"><link rel="prefetch" href="/assets/js/17.85b26636.js"><link rel="prefetch" href="/assets/js/18.1172ae07.js"><link rel="prefetch" href="/assets/js/19.02da22ed.js"><link rel="prefetch" href="/assets/js/20.899cfc38.js"><link rel="prefetch" href="/assets/js/21.48a7b777.js"><link rel="prefetch" href="/assets/js/22.ae905edc.js"><link rel="prefetch" href="/assets/js/23.145304b2.js"><link rel="prefetch" href="/assets/js/24.fc9aa772.js"><link rel="prefetch" href="/assets/js/25.5370690c.js"><link rel="prefetch" href="/assets/js/26.4092c0ff.js"><link rel="prefetch" href="/assets/js/27.211a8f61.js"><link rel="prefetch" href="/assets/js/28.7b4de4b7.js"><link rel="prefetch" href="/assets/js/29.443848ae.js"><link rel="prefetch" href="/assets/js/30.8fb8f839.js"><link rel="prefetch" href="/assets/js/31.39c4255a.js"><link rel="prefetch" href="/assets/js/32.6e0fb50b.js"><link rel="prefetch" href="/assets/js/33.919f59b2.js"><link rel="prefetch" href="/assets/js/34.2fd50063.js"><link rel="prefetch" href="/assets/js/35.3dfac06e.js"><link rel="prefetch" href="/assets/js/36.a873c79a.js"><link rel="prefetch" href="/assets/js/37.85faec35.js"><link rel="prefetch" href="/assets/js/38.e83fe327.js"><link rel="prefetch" href="/assets/js/39.6be1856f.js"><link rel="prefetch" href="/assets/js/4.78206645.js"><link rel="prefetch" href="/assets/js/40.93ddf935.js"><link rel="prefetch" href="/assets/js/41.88d92bf1.js"><link rel="prefetch" href="/assets/js/42.b3d6f88b.js"><link rel="prefetch" href="/assets/js/43.1c5dc4d4.js"><link rel="prefetch" href="/assets/js/44.195f887c.js"><link rel="prefetch" href="/assets/js/45.9aec365f.js"><link rel="prefetch" href="/assets/js/46.a1714c92.js"><link rel="prefetch" href="/assets/js/47.07f6e748.js"><link rel="prefetch" href="/assets/js/48.edfe58e7.js"><link rel="prefetch" href="/assets/js/5.290e8a5b.js"><link rel="prefetch" href="/assets/js/6.0be4f557.js"><link rel="prefetch" href="/assets/js/8.9882d415.js"><link rel="prefetch" href="/assets/js/9.62493693.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.07834b74.js">
    <link rel="stylesheet" href="/assets/css/0.styles.efb332ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout"><nav role="navigation" aria-label="main navigation" class="navbar is-primary is-fixed-top"><div class="navbar-brand"><a href="/" to="/" class="navbar-item router-link-active">
        NeroBlackstone's Blog
    </a><a role="button" aria-label="menu" class="navbar-burger burger"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-start"></div><div class="navbar-end"><a href="/tag/" to="/tag/" class="navbar-item">Tag</a> <a href="/friends/" to="/friends/" class="navbar-item">Friends</a></div></div></nav> <section class="section"><div class="container"><div class="content__default"><h1 id="jvm-zgc-简介"><a href="#jvm-zgc-简介" class="header-anchor">#</a> JVM ZGC 简介</h1> <p>如今服务端面向百万级的客户端服务的场景已经越来越常见。这样的程序需要大量的内存，传统方法管理这些内存也会导致一些性能问题。</p> <p>Java 11 引入的实验性GC实现：ZGC，便是为了解决这个问题。</p> <p>本文介绍ZGC如何在高达TB级的堆中以极低的暂停时间回收内存。</p> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <p>为了理解ZGC如何工作，首先需要了解一些内存管理和GC有关的基础概念和理论。</p> <h3 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h3> <p>物理内存，是电脑硬件提供的内存。虚拟内存，是操作系统堆为每个应用分配的内存。我们将<strong>虚拟内存存储到物理内存中，并且OS实时地维护两者的映射</strong>。</p> <h3 id="多重映射（multi-mapping）"><a href="#多重映射（multi-mapping）" class="header-anchor">#</a> 多重映射（Multi-mapping）</h3> <p>多重映射意味着虚拟内存中有指向物理内存的特殊地址。由于程序通过虚拟内存访问数据，程序不知道也不需要知道这里的底层机制。</p> <p><strong>实际上，os会把相同区域的物理内存分配到多块物理内存当中。</strong></p> <p><img src="data:image/png;base64,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" alt="jvm-multi-mapping"></p> <p>看上去这样做并没有什么好处，但是这是ZGC实现的基础，并且由于这种机制分离了应用程序的间的内存空间，保障了安全性。</p> <h3 id="再分配"><a href="#再分配" class="header-anchor">#</a> 再分配</h3> <p>由于使用动态内存分配，普通程序的内存会随着运行时间推移变得碎片化。这是因为在内存中清除对象时，会留下那段内存被释放后的内存间隙。随着时间流逝，间隙不断积累，内存会变得像是由可用空间和已用空间交织的棋盘格。</p> <p>当然我们可以尝试使用新对象去填补这些空白。要做到这一点，可以扫描内存，去找到足够容纳新对象的可用空间。如果每次分配内存都要执行这种操作，将会非常耗时。此外，由于有可能不能找到刚好大小合适的内存空间，内存仍将是零碎的，对象间将存在非常小的间隙。也可以尝试最小化这些间隙，但也需要更多的处理资源。</p> <p>另外一种策略是更频繁地<strong>从碎片化的内存中，移动对象到一块新的可用区域，使分区更加紧凑</strong>。为了追求效率，可以把内存分割为一个个小区块，移动对象以填满区块，或保持区块为空。这样下来，由于知道这些一整块为空的区块的存在，内存分配将会更加快速。</p> <h3 id="gc"><a href="#gc" class="header-anchor">#</a> GC</h3> <p>上面讲的是JVM出现前的情况（回顾大学里操作系统课的内容）。当创建java程序时，我们其实不用释放我们分配出去的内存，因为垃圾收集器会帮我们全部搞定。<strong>GC通过引用链监视着程序中无法到达的对象，并且释放这些对象占用的内存</strong>。</p> <p>GC需要跟踪堆空间中对象的状态来完成工作。举个例子，<strong>可达状态</strong>意味着程序保有这个对象的引用，当然这个引用也是可传递的，只要程序可以访问这些引用找到对象即可。另一个状态是<strong>可终结状态</strong>：无法访问的对象即为可终结的，这些对象就是我们要去回收的垃圾。</p> <p><img src="data:image/png;base64,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" alt="jvm-multi-mapping"></p> <p>GC会走多个步骤去获取堆空间的对象可达性信息。</p> <h3 id="gc阶段"><a href="#gc阶段" class="header-anchor">#</a> GC阶段</h3> <p>GC阶段有着不同的属性</p> <ul><li>parallel阶段可以运行多个GC线程</li> <li>serail阶段运行在单个线程上</li> <li>stop-the-world阶段不能与应用代码一同运行</li> <li>concurrent阶段可以在后台工作，程序可照常运行</li> <li>increment阶段可以在结束前暂停所有的工作，并且稍后重启</li></ul> <p>上述所有技术都有其优缺点。举个例子，假设有一个可以和我们的程序代码并发运行的阶段。使用serial实现只需要1%的cpu占用，但是需要运行1000毫秒。而相反，使用parallel实现需要占用30%的cpu并且仅仅50ms完成工作。</p> <p>看起使用parallel实现非常快，但是<strong>parallel的解决方案使用了更多cpu，因为它更加复杂并且必须同步线程</strong>。对于cpu占用高的应用（像批处理）就不太适合，因为用于真正有意义的工作的cpu变少了。</p> <p>虽然这只是举个例子，但是很明显所有程序都有它自己的特征，不同的程序会有不同的GC要求。（软件工程没有银弹）</p> <h2 id="zgc概念"><a href="#zgc概念" class="header-anchor">#</a> ZGC概念</h2> <p>ZGC的目标是让stop-the-world阶段尽可能短，并且暂停时间不会随着堆大小的增大而增大。<strong>这些特性使ZGC更加适应占内存极大的服务端程序，或者是那些需要快速响应的程序。</strong></p> <h3 id="总览"><a href="#总览" class="header-anchor">#</a> 总览</h3> <p>ZGC有一个叫Marking的阶段，目标是找到可达的对象。GC有多种方式存储对象状态信息。举个例子，我们可以创建一个Map，key为内存地址，值为那个地址中对象的状态。这样存储非常简单容易，但是需要额外的内存来存储这些信息。维护这些Map也有难度。</p> <p><strong>因此ZGC使用了一个不同的方法：它用引用的位（bit）来存储引用状态</strong>。（看不懂这句话的话可以暂时忽略，下文会讲。）这被称为<strong>引用着色</strong>（reference coloring）。但是这又带来一个新问题。设置引用的位以存储关于对象的元数据，意味着多个引用可以指向同一对象，因为状态位不持有任何有关对象位置的信息。这个问题可以使用上文提到的多重映射（Multi-mapping）解决。</p> <p>ZGC还可以通过重定位（relocation）来减少内存碎片。但是对于比较大的堆来说，重定位是一个非常缓慢的过程。<strong>由于ZGC不希望长时间的暂停，因此它并行地在程序运行时重定位。</strong> 但是这又导致了新问题。</p> <p>假设我们现在有一个对象的引用。ZGC将内存区域重定位时发生了上下文的切换，应用程序线程这时会尝试以老地址访问对象。ZGC使用<strong>负载屏障</strong>(load barriers)去解决这个问题。<strong>负载屏障是当一个线程从堆中加载引用时，运行的一段代码</strong>。比如当我们访问对象的<strong>非原始（non-primitive）类型对象</strong>字段时，就是从堆中加载引用的过程。</p> <p>在ZGC中，负载屏障检查了引用的元数据位。根据这些比特位，ZGC可能会在我们拿到这些引用前执行一些处理。因此实际上我们可能会拿到完全不同的应用。这个步骤叫做重映射（remapping）。（注意不是上面的多重映射Multi-mapping）。</p> <h3 id="标记-marking"><a href="#标记-marking" class="header-anchor">#</a> 标记/Marking</h3> <p>ZGC将Marking分为三个阶段来执行。</p> <ul><li>第一个阶段是stop-the-world。在这个阶段中，我们根据根引用进行标记。<strong>根引用是到达堆中对象的起点。</strong> 比如局部变量或静态变量就是根引用。由于根引用的数量一般比较少，因此这个阶段非常短暂。</li> <li>下一个阶段是concurrent（并发）。在这个阶段， <strong>ZGC会从根引用开始遍历对象图，标记每一个到达的对象。</strong> 同样的，当负载屏障检测到未标记的引用，它也会标记它。</li> <li>最后一个阶段仍然是stop-the-world，用于处理一些边缘情况（像弱引用之类的）。</li></ul> <p>自此，我们可以知道哪些对象是可达的。ZGC会使用<em>marked0</em>和<em>marked1</em>元数据位来标记。</p> <h3 id="引用着色-reference-coloring"><a href="#引用着色-reference-coloring" class="header-anchor">#</a> 引用着色/Reference Coloring</h3> <p>引用表示了虚拟内存中字节的位置。然而并不需要使用引用的全部比特位来表示位置（这给我们使用引用本身去标识引用状态留下了操作空间）， <strong>一些比特位代表着引用的属性。</strong> 这就是所谓的引用着色。</p> <p>在32位os中，我们只能寻址4GB。但是现代计算机的内存一般不止这么点，所以这32位没有一位可以拿来着色。因此ZGC使用的是64位引用，ZGC也只在64位平台可用。</p> <p><img src="data:image/png;base64,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" alt="zgc-pointer"></p> <p>ZGC使用42比特位来代表地址本身。这意味着ZGC可以寻址至多4TB的内存空间。</p> <p>如上图所示，ZGC有4比特位来存储引用状态：</p> <ul><li><strong>finalizable bit</strong> 该对象只能被GC的finalizer访问。</li> <li><strong>remap bit</strong> 引用状态是最新的，指向对象的当前位置。（详见上文的重定位）</li> <li><strong>marked0</strong> 和 <strong>marked1</strong>。用于标记可达对象</li></ul> <h3 id="重定位-relocation"><a href="#重定位-relocation" class="header-anchor">#</a> 重定位/Relocation</h3> <p>在ZGC中，重定位由下列几个阶段组成。</p> <ol><li>concurrent阶段，这个阶段会查找需要重定位的内存区块，并且将其放入重定位集。</li> <li>stop-the-world阶段，将重定位集中的所有根引用重新定位，并且更新引用。</li> <li>concurrent阶段，重定位所有重定位集中剩下的对象，并且在转发表中存储老地址到新地址间的映射。</li> <li>其余引用的重写会发生在下一个标记阶段。这样就不需要遍历对象树两次。负载屏障也可以起这个作用</li></ol> <h3 id="重映射与负载屏障"><a href="#重映射与负载屏障" class="header-anchor">#</a> 重映射与负载屏障</h3> <p>在重定位阶段,对于重定位了的地址，大多数的引用并没有被改写。因此，如果访问这些引用，我们是没办法找到想要的对象的。更糟糕的情况是，我们可能会访问到垃圾。</p> <p>ZGC使用了负载屏障来解决这个问题。<strong>负载屏障了修复引用指向问题以指向重定位后的对象，它使用到了被称为重映射的技术。</strong></p> <p>当应用加载引用时就会触发负载屏障，然后依据下面的步骤返回正确的引用：</p> <ol><li>检查<em>remap</em> bit是否被设置为了1。如果是1，则表示引用是最新的，可以安全地返回这个引用。</li> <li>然后检查被引用的对象是否在重定位集中。如果不在重定位集中，那就意味着这个对象不需要被重定位（引用已经被更新）。接下来为了避免下一次再进行这个检查，把<em>remap</em> bit设置为1，并且返回更新的引用。</li> <li>到了这一步，我们可以得知访问的对象是重定位集以内的对象。下面的问题是确定这个对象是否被重定位过。如果该对象曾经被重定位，直接跳到下一步。反之，现在就开始进行对象的重定位，并且在转发表中增加一个新条目，用以记录对象重定位后的新地址。之后进行下一步。</li> <li>现在可以确定这个对象已经被重定位过了。要么是上一步ZGC对其进行了重定位，要么是更早以前的负载屏障对该对象进行了操作。现在更新这个对象的新引用（使用上一步的地址或者通过查找转发表查找到新地址），设置好<em>remap</em> bit，返回这个引用。</li></ol> <p>每次加载引用时都会触发负载屏障，重复上面的步骤，以确保每次访问对象时，都可以取到最新的引用。这实际上会稍微降低程序执行的性能，特别是第一次访问重定位的对象时。但是这是为了缩短暂停时间所必须付出的代价。并且由于这些步骤相对较快，因此不会太显著影响地程序的性能。（实际上就是在完全冻结主程序，和并行运行主程序中招平衡）</p> <h2 id="现在就开启zgc！"><a href="#现在就开启zgc！" class="header-anchor">#</a> 现在就开启ZGC！</h2> <p>在运行程序时使用以下命令即可启用ZGC：</p> <blockquote><p>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</p></blockquote> <p>这玩意到目前未知都是实验性GC，但是相较于java11，现在的java13可以支持高达16TB的heap size。（那么看完了这篇文章的你应该能反应过来引用位的变化）</p> <p>另外java13也添加了zgc的mac os支持，在下一个java14中，将会添加Windows的支持。这样应该算是全平台可用了。</p></div> <!----></div></section> <footer class="footer" data-v-29777868><div class="level" data-v-29777868><div class="content level-item has-text-centered" data-v-29777868><div class="field is-grouped-multiline is-grouped" data-v-29777868><!----> <div class="control" data-v-29777868><span class="tag is-primary" data-v-29777868><span><a href="https://github.com/NeroBlackstone" class="has-text-white" data-v-29777868><span class="icon" data-v-29777868><i class="fab fa-github" data-v-29777868></i></span></a></span> <!----></span></div> <div class="control" data-v-29777868><a href="https://v1.vuepress.vuejs.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>vuepress</span> <!----></span> <span class="tag is-info" data-v-29777868><span>1.5.0</span> <!----></span></div></a></div><div class="control" data-v-29777868><a href="https://buefy.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>buefy</span> <!----></span> <span class="tag is-info" data-v-29777868><span>0.8.20</span> <!----></span></div></a></div> <!----></div></div></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ec2d5af2.js" defer></script><script src="/assets/js/3.e9bff2d3.js" defer></script><script src="/assets/js/7.df8bc73d.js" defer></script>
  </body>
</html>
