<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>java的强／弱／软／虚引用 | NeroBlackstone&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.efb332ed.css" as="style"><link rel="preload" href="/assets/js/app.ec2d5af2.js" as="script"><link rel="preload" href="/assets/js/3.e9bff2d3.js" as="script"><link rel="preload" href="/assets/js/29.443848ae.js" as="script"><link rel="prefetch" href="/assets/js/10.7e730691.js"><link rel="prefetch" href="/assets/js/11.0a8c3a3b.js"><link rel="prefetch" href="/assets/js/12.e41009b6.js"><link rel="prefetch" href="/assets/js/13.615800ed.js"><link rel="prefetch" href="/assets/js/14.9ff2a10b.js"><link rel="prefetch" href="/assets/js/15.c0f3d8e0.js"><link rel="prefetch" href="/assets/js/16.267a81c0.js"><link rel="prefetch" href="/assets/js/17.85b26636.js"><link rel="prefetch" href="/assets/js/18.1172ae07.js"><link rel="prefetch" href="/assets/js/19.02da22ed.js"><link rel="prefetch" href="/assets/js/20.899cfc38.js"><link rel="prefetch" href="/assets/js/21.48a7b777.js"><link rel="prefetch" href="/assets/js/22.ae905edc.js"><link rel="prefetch" href="/assets/js/23.145304b2.js"><link rel="prefetch" href="/assets/js/24.fc9aa772.js"><link rel="prefetch" href="/assets/js/25.5370690c.js"><link rel="prefetch" href="/assets/js/26.4092c0ff.js"><link rel="prefetch" href="/assets/js/27.211a8f61.js"><link rel="prefetch" href="/assets/js/28.7b4de4b7.js"><link rel="prefetch" href="/assets/js/30.8fb8f839.js"><link rel="prefetch" href="/assets/js/31.39c4255a.js"><link rel="prefetch" href="/assets/js/32.6e0fb50b.js"><link rel="prefetch" href="/assets/js/33.919f59b2.js"><link rel="prefetch" href="/assets/js/34.2fd50063.js"><link rel="prefetch" href="/assets/js/35.3dfac06e.js"><link rel="prefetch" href="/assets/js/36.a873c79a.js"><link rel="prefetch" href="/assets/js/37.85faec35.js"><link rel="prefetch" href="/assets/js/38.e83fe327.js"><link rel="prefetch" href="/assets/js/39.6be1856f.js"><link rel="prefetch" href="/assets/js/4.78206645.js"><link rel="prefetch" href="/assets/js/40.93ddf935.js"><link rel="prefetch" href="/assets/js/41.88d92bf1.js"><link rel="prefetch" href="/assets/js/42.b3d6f88b.js"><link rel="prefetch" href="/assets/js/43.1c5dc4d4.js"><link rel="prefetch" href="/assets/js/44.195f887c.js"><link rel="prefetch" href="/assets/js/45.9aec365f.js"><link rel="prefetch" href="/assets/js/46.a1714c92.js"><link rel="prefetch" href="/assets/js/47.07f6e748.js"><link rel="prefetch" href="/assets/js/48.edfe58e7.js"><link rel="prefetch" href="/assets/js/5.290e8a5b.js"><link rel="prefetch" href="/assets/js/6.0be4f557.js"><link rel="prefetch" href="/assets/js/7.df8bc73d.js"><link rel="prefetch" href="/assets/js/8.9882d415.js"><link rel="prefetch" href="/assets/js/9.62493693.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.07834b74.js">
    <link rel="stylesheet" href="/assets/css/0.styles.efb332ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout"><nav role="navigation" aria-label="main navigation" class="navbar is-primary is-fixed-top"><div class="navbar-brand"><a href="/" to="/" class="navbar-item router-link-active">
        NeroBlackstone's Blog
    </a><a role="button" aria-label="menu" class="navbar-burger burger"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-start"></div><div class="navbar-end"><a href="/tag/" to="/tag/" class="navbar-item">Tag</a> <a href="/friends/" to="/friends/" class="navbar-item">Friends</a></div></div></nav> <section class="section"><div class="container"><div class="content__default"><h1 id="java的强／弱／软／虚引用"><a href="#java的强／弱／软／虚引用" class="header-anchor">#</a> java的强／弱／软／虚引用</h1> <p>这篇文章讨论java的四种引用类型。</p> <h2 id="强引用"><a href="#强引用" class="header-anchor">#</a> 强引用</h2> <p>强引用是我们最常用的引用类型。类似val obj=Any()的引用即为强引用。任何被强引用指向的对象均不适合于GC。</p> <h2 id="软引用"><a href="#软引用" class="header-anchor">#</a> 软引用</h2> <p>在jvm绝对需要内存前，软引用指向的对象不会被回收。</p> <p>建立软引用代码如下：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> builder <span class="token operator">=</span> <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> reference1 <span class="token operator">=</span> <span class="token function">SoftReference</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span>
</code></pre></div><p>软引用的取得与清除:</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> builder1<span class="token operator">:</span> StringBuilder <span class="token operator">=</span> reference2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
reference2<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> builder2<span class="token operator">:</span> StringBuilder <span class="token operator">=</span> reference2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// null</span>
</code></pre></div><p>或是初始化时与引用队列关联：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> referenceQueue <span class="token operator">=</span> ReferenceQueue<span class="token operator">&lt;</span>StringBuilder<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> reference2 <span class="token operator">=</span> <span class="token function">SoftReference</span><span class="token punctuation">(</span>builder<span class="token punctuation">,</span> referenceQueue<span class="token punctuation">)</span>
</code></pre></div><p>软引用使用前要记得判空：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> builder3<span class="token operator">:</span> StringBuilder <span class="token operator">=</span> reference2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>builder3 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
<span class="token comment">// GC hasn't removed the instance yet</span>
<span class="token keyword">else</span> 
<span class="token comment">// GC has cleared the instance</span>
</code></pre></div><h2 id="弱引用"><a href="#弱引用" class="header-anchor">#</a> 弱引用</h2> <p><strong>当弱引用对象不可达时，GC会将其清除。</strong></p> <p>弱引用对象会被GC优先回收，GC不会等到需要内存的时候再去回收弱引用对象。</p> <p>弱可达性意味着<strong>这个对象既没有被强引用指向，也没有被软引用指向。</strong> 唯有遍历弱引用，才能达到该对象。</p> <p>GC会优先清除弱引用，所以被引用对象将不再可达。然后这个引用会放置在引用队列中（如果事先给弱引用关联了引用队列），我们可以从引用队列中拿到被清除的引用。</p> <p>与此同时，不可达的软引用对象将被GC回收。</p> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <p>根据java官方文档，<strong>弱引用最常用于实现规范化的映射。</strong> 如果某映射只有一个特定值的实例，这个映射就是规范化的。</p> <p><strong>WeakHashMap就使用了弱引用。</strong> 它实现了<em>Map</em>接口，但是每个键都使用弱引用来存储。当GC移除键后，与键关联的实体也一并删除。</p> <p>另一个使用场景是解决<a href="https://en.wikipedia.org/wiki/Lapsed_listener_problem" target="_blank" rel="noopener noreferrer">Lapsed Listener<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 问题。</p> <p>发布者拥有对所有订阅者的强引用，以此来通知订阅者有事件发生。但是<strong>如果订阅者不能成功地取消订阅，就会出现内存问题。</strong></p> <p>因为发布者依然持有对订阅者的强引用，订阅者是不会被GC回收的，这样就产生了内存泄漏。</p> <p>解决方法是发布者对订阅者持有弱引用，允许订阅者被垃圾回收，而不需要取消订阅。（注意这并不是完整的解决方案，它也会引入一些这里没提到的其他的问题）</p> <h3 id="弱引用代码实例"><a href="#弱引用代码实例" class="header-anchor">#</a> 弱引用代码实例</h3> <p>弱引用由<em>java.lang.ref.WeakReference</em>类表示。可以通过传入需要引用的对象来初始化弱引用。也可以提供一个相关联的引用队列。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> referent <span class="token operator">=</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> referenceQueue <span class="token operator">=</span> ReferenceQueue<span class="token operator">&lt;</span>Any<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> weakReference1<span class="token operator">:</span> WeakReference<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">WeakReference</span><span class="token punctuation">(</span>referent<span class="token punctuation">)</span>
<span class="token keyword">val</span> weakReference2<span class="token operator">:</span> WeakReference<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">WeakReference</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> referenceQueue<span class="token punctuation">)</span>
</code></pre></div><p>其余操作均与上文的软引用相同。</p> <h2 id="虚引用"><a href="#虚引用" class="header-anchor">#</a> 虚引用</h2> <p><strong>虚引用无法被直接取得。</strong> 这也是为什么一定需要引用队列来使用虚引用。<strong>GC执行finalize()方法后</strong> ，虚引用会被添加到引用队列。但是这时对象示实例仍存在内存中。</p> <h3 id="使用场景-2"><a href="#使用场景-2" class="header-anchor">#</a> 使用场景</h3> <p>虚引用可以用来<strong>确定一个对象何时从内存中释放</strong> ，我们可以等一个占空间很大的对象被移除再加载另一个对象。虚引用还可以让我们<strong>使用自定义的finalize方法</strong>。</p> <h3 id="代码实例"><a href="#代码实例" class="header-anchor">#</a> 代码实例</h3> <p>详细讲一下上文第二个使用场景，首先需要 PhantomReference的子类定义如何清除对象的方法。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">LargeObjectFinalizer</span><span class="token punctuation">(</span>referent<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> q<span class="token operator">:</span> ReferenceQueue<span class="token operator">&lt;</span><span class="token keyword">in</span> Any<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">:</span> PhantomReference<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">finalizeResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// free resources</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;clearing ...&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在可以控制每一个对象的finalization处理：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> referenceQueue <span class="token operator">=</span> ReferenceQueue<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> references<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>LargeObjectFinalizer<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> largeObjects<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> largeObject <span class="token operator">=</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    largeObjects<span class="token operator">!!</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>largeObject<span class="token punctuation">)</span>
    references<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">LargeObjectFinalizer</span><span class="token punctuation">(</span>largeObject<span class="token punctuation">,</span> referenceQueue<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

largeObjects <span class="token operator">=</span> <span class="token keyword">null</span>
System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> referenceFromQueue<span class="token operator">:</span> Reference<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>reference <span class="token keyword">in</span> references<span class="token punctuation">)</span> 
    <span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span>isEnqueued<span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>referenceQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span> referenceFromQueue <span class="token operator">=</span> it <span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>referenceFromQueue <span class="token keyword">as</span> LargeObjectFinalizer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finalizeResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    referenceFromQueue<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>先初始化所有必须的对象：</p> <ul><li>referenceQueue 用于跟踪入队的引用</li> <li>references 执行清除工作</li> <li>largeObjects 假装是个很大的数据结构</li></ul> <p>接下来初始化largeObject并且将其加入largeObjects的列表中，再把largeObject与引用队列相关联，构成虚引用，加入到虚引用列表中。</p> <p>在调用GC前，我们可以通过取消largeObjects的引用，手动释放数据。System.gc()相当于调用Runtime.getRuntime().gc() (可查看java源码得知)。</p> <p>不过Systm.gc并不会立即触发gc，它只是通知JVM去执行gc。</p> <p>下面for循环内确保所有虚引用已经进入引用队列。每个引用均会打印true。</p> <p>最后使用while循环轮讯入队引用并且执行自定义的清除工作。</p></div> <!----></div></section> <footer class="footer" data-v-29777868><div class="level" data-v-29777868><div class="content level-item has-text-centered" data-v-29777868><div class="field is-grouped-multiline is-grouped" data-v-29777868><!----> <div class="control" data-v-29777868><span class="tag is-primary" data-v-29777868><span><a href="https://github.com/NeroBlackstone" class="has-text-white" data-v-29777868><span class="icon" data-v-29777868><i class="fab fa-github" data-v-29777868></i></span></a></span> <!----></span></div> <div class="control" data-v-29777868><a href="https://v1.vuepress.vuejs.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>vuepress</span> <!----></span> <span class="tag is-info" data-v-29777868><span>1.5.0</span> <!----></span></div></a></div><div class="control" data-v-29777868><a href="https://buefy.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>buefy</span> <!----></span> <span class="tag is-info" data-v-29777868><span>0.8.20</span> <!----></span></div></a></div> <!----></div></div></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ec2d5af2.js" defer></script><script src="/assets/js/3.e9bff2d3.js" defer></script><script src="/assets/js/29.443848ae.js" defer></script>
  </body>
</html>
