<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM中的堆和栈 | NeroBlackstone&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.efb332ed.css" as="style"><link rel="preload" href="/assets/js/app.ec2d5af2.js" as="script"><link rel="preload" href="/assets/js/3.e9bff2d3.js" as="script"><link rel="preload" href="/assets/js/11.0a8c3a3b.js" as="script"><link rel="prefetch" href="/assets/js/10.7e730691.js"><link rel="prefetch" href="/assets/js/12.e41009b6.js"><link rel="prefetch" href="/assets/js/13.615800ed.js"><link rel="prefetch" href="/assets/js/14.9ff2a10b.js"><link rel="prefetch" href="/assets/js/15.c0f3d8e0.js"><link rel="prefetch" href="/assets/js/16.267a81c0.js"><link rel="prefetch" href="/assets/js/17.85b26636.js"><link rel="prefetch" href="/assets/js/18.1172ae07.js"><link rel="prefetch" href="/assets/js/19.02da22ed.js"><link rel="prefetch" href="/assets/js/20.899cfc38.js"><link rel="prefetch" href="/assets/js/21.48a7b777.js"><link rel="prefetch" href="/assets/js/22.ae905edc.js"><link rel="prefetch" href="/assets/js/23.145304b2.js"><link rel="prefetch" href="/assets/js/24.fc9aa772.js"><link rel="prefetch" href="/assets/js/25.5370690c.js"><link rel="prefetch" href="/assets/js/26.4092c0ff.js"><link rel="prefetch" href="/assets/js/27.211a8f61.js"><link rel="prefetch" href="/assets/js/28.7b4de4b7.js"><link rel="prefetch" href="/assets/js/29.443848ae.js"><link rel="prefetch" href="/assets/js/30.8fb8f839.js"><link rel="prefetch" href="/assets/js/31.39c4255a.js"><link rel="prefetch" href="/assets/js/32.6e0fb50b.js"><link rel="prefetch" href="/assets/js/33.919f59b2.js"><link rel="prefetch" href="/assets/js/34.2fd50063.js"><link rel="prefetch" href="/assets/js/35.3dfac06e.js"><link rel="prefetch" href="/assets/js/36.a873c79a.js"><link rel="prefetch" href="/assets/js/37.85faec35.js"><link rel="prefetch" href="/assets/js/38.e83fe327.js"><link rel="prefetch" href="/assets/js/39.6be1856f.js"><link rel="prefetch" href="/assets/js/4.78206645.js"><link rel="prefetch" href="/assets/js/40.93ddf935.js"><link rel="prefetch" href="/assets/js/41.88d92bf1.js"><link rel="prefetch" href="/assets/js/42.b3d6f88b.js"><link rel="prefetch" href="/assets/js/43.1c5dc4d4.js"><link rel="prefetch" href="/assets/js/44.195f887c.js"><link rel="prefetch" href="/assets/js/45.9aec365f.js"><link rel="prefetch" href="/assets/js/46.a1714c92.js"><link rel="prefetch" href="/assets/js/47.07f6e748.js"><link rel="prefetch" href="/assets/js/48.edfe58e7.js"><link rel="prefetch" href="/assets/js/5.290e8a5b.js"><link rel="prefetch" href="/assets/js/6.0be4f557.js"><link rel="prefetch" href="/assets/js/7.df8bc73d.js"><link rel="prefetch" href="/assets/js/8.9882d415.js"><link rel="prefetch" href="/assets/js/9.62493693.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.07834b74.js">
    <link rel="stylesheet" href="/assets/css/0.styles.efb332ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout"><nav role="navigation" aria-label="main navigation" class="navbar is-primary is-fixed-top"><div class="navbar-brand"><a href="/" to="/" class="navbar-item router-link-active">
        NeroBlackstone's Blog
    </a><a role="button" aria-label="menu" class="navbar-burger burger"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-start"></div><div class="navbar-end"><a href="/tag/" to="/tag/" class="navbar-item">Tag</a> <a href="/friends/" to="/friends/" class="navbar-item">Friends</a></div></div></nav> <section class="section"><div class="container"><div class="content__default"><h1 id="jvm中的堆和栈"><a href="#jvm中的堆和栈" class="header-anchor">#</a> JVM中的堆和栈</h1> <p>为了让程序可以以最佳的状态运行，java把内存分为了堆和栈。<strong>每当我们声明新的对象和变量，调用新的方法，声明字符串或执行更多此类相似的操作，JVM都会从堆或栈中为这些操作分配空间。</strong></p> <p>本文将讨论这两个内存模型。我将会列举堆和栈的几个关键的不同，以及阐述它们是如何存储在物理内存中的，还有它们提供给我们的一些特性，何时去使用它们。</p> <h2 id="java中的栈"><a href="#java中的栈" class="header-anchor">#</a> java中的栈</h2> <p><strong>java中的栈被用于静态内存分配和执行线程。</strong> 它包含函数中的原始类型值，和函数中的引用，这些引用指向的对象存储在堆中。</p> <p>访问栈中内存需要按照后进先出的顺序。每当调用一个新方法时，栈顶就会创建一个新的区块，这个区块包含了和这个函数有关的一些特定的值，例如原始类型变量和对象的引用。</p> <p>该方法执行完毕后，将刷新相应的堆帧，数据回流到所调用方法中，该区块被清空，为下一个要执行的函数腾出空间。</p> <h3 id="栈的关键特性"><a href="#栈的关键特性" class="header-anchor">#</a> 栈的关键特性</h3> <p>除了上文讨论的内容，栈还有如下特性：</p> <ul><li>随着新方法的调用和返回，栈的大小会自动增长和收缩。</li> <li>栈中的变量仅在创建这些变量的方法运行时存在。</li> <li>方法执行完毕后栈内空间会自动分配和释放。</li> <li>如果栈内存已满，java会丢出<em>java.lang.StackOverFlowError</em>异常。</li> <li>相比与访问堆内存，访问栈内存更快。</li> <li>栈内存是线程安全的，因为每个线程只操作自己的栈。</li></ul> <h2 id="java中的堆"><a href="#java中的堆" class="header-anchor">#</a> java中的堆</h2> <p><strong>java中的堆空间被用于java对象和JRE类在运行时的动态内存分配。</strong> 新的对象总是在堆中创建，并且该对象的引用被存储在栈中。</p> <p>这些对象具有全局访问属性，可以从程序的任何位置被访问。</p> <p>在之前的JVM实现中堆中会被细分为世代以便于GC回收内存，但是新的ZGC已经不通过世代来回收内存，每次GC都会标记整个堆空间。故有关世代的内容本文不再阐述。</p> <h3 id="堆的关键特性"><a href="#堆的关键特性" class="header-anchor">#</a> 堆的关键特性</h3> <p>除了上文提到的内容，堆还有如下特性：</p> <ul><li>如果堆已满，会抛出<em>java.lang.OutOfMemoryError</em>异常</li> <li>对该堆内存的访问会比栈内存慢</li> <li>与栈相比，堆空间不会自动释放。它需要GC去清空无用的对象，以保持内存使用的效率</li> <li>与栈不同，堆不是线程安全的，并且需要被正确的同步代码保护</li></ul> <h2 id="代码示例"><a href="#代码示例" class="header-anchor">#</a> 代码示例</h2> <p>基于上文的知识点，来分析一段简单的kotlin代码吧！</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span>pid<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> id <span class="token operator">=</span> <span class="token number">23</span>
    <span class="token keyword">val</span> pName <span class="token operator">=</span> <span class="token string">&quot;Jon&quot;</span>
    <span class="token keyword">var</span> p<span class="token operator">:</span> Person<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    p <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> pName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li>进入<em>main()</em> 方法后，栈会创建空间来存放原始类型和对象的引用。</li></ol> <ul><li>整数的原始类型值<em>id</em> 会被直接存到栈内。</li> <li><em>Person</em> 类型的变量<em>p</em> 的引用也会被存于栈空间，该引用会指向堆中的实际对象</li></ul> <ol start="2"><li>从<em>main()</em> 中调用带参构造函数<em>Person(Int,String?)</em> 将会在栈顶分配内存。用于存储：</li></ol> <ul><li><em>this</em> 对象的引用</li> <li>原始类型值<em>id</em></li> <li>参数<em>personName</em>的<em>String?</em> 类型的变量的引用，将会指向堆内存中的字符串池中的实际字符串</li></ul> <ol start="3"><li>此默认构造函数将进一步调用隐式的<em>setName（）</em> 方法，栈顶也会为这个方法分配内存，然后以上文提到的方式再一次存储变量。</li> <li>对于新创建的<em>Person</em> 类型的对象<em>p</em> ，所有的实例变量将存到堆内存中。</li></ol> <p>整个分配如下图所示:</p> <p><img src="/assets/img/Stack-Memory-vs-Heap-Space-in-Java.79cd68dc.jpg" alt="Stack-Memory-vs-Heap-Space-in-Java"></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <table><thead><tr><th>参数</th> <th style="text-align:center;">栈</th> <th style="text-align:center;">堆</th></tr></thead> <tbody><tr><td>应用场景</td> <td style="text-align:center;">栈在局部使用，在线程执行期间一次只访问一个栈</td> <td style="text-align:center;">整个程序在运行时都会使用堆空间</td></tr> <tr><td>容量大小</td> <td style="text-align:center;">根据os不同，栈有大小限制，通常比堆低</td> <td style="text-align:center;">堆没有大小限制</td></tr> <tr><td>存储</td> <td style="text-align:center;">只存储原始类型变量和堆中对象的引用</td> <td style="text-align:center;">存储所有新创建的对象</td></tr> <tr><td>生命周期</td> <td style="text-align:center;">栈只存在于当前方法运行的时候</td> <td style="text-align:center;">只要程序在运行，堆空间就存在</td></tr> <tr><td>分配效率</td> <td style="text-align:center;">相较于堆分配较快</td> <td style="text-align:center;">相较与栈分配较慢</td></tr> <tr><td>分配/释放</td> <td style="text-align:center;">当方法被调用时和返回时，内存自动分配和释放</td> <td style="text-align:center;">当新对象被创建时，分配堆空间，当对象不再被引用时，GC释放空间</td></tr></tbody></table></div> <!----></div></section> <footer class="footer" data-v-29777868><div class="level" data-v-29777868><div class="content level-item has-text-centered" data-v-29777868><div class="field is-grouped-multiline is-grouped" data-v-29777868><!----> <div class="control" data-v-29777868><span class="tag is-primary" data-v-29777868><span><a href="https://github.com/NeroBlackstone" class="has-text-white" data-v-29777868><span class="icon" data-v-29777868><i class="fab fa-github" data-v-29777868></i></span></a></span> <!----></span></div> <div class="control" data-v-29777868><a href="https://v1.vuepress.vuejs.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>vuepress</span> <!----></span> <span class="tag is-info" data-v-29777868><span>1.5.0</span> <!----></span></div></a></div><div class="control" data-v-29777868><a href="https://buefy.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>buefy</span> <!----></span> <span class="tag is-info" data-v-29777868><span>0.8.20</span> <!----></span></div></a></div> <!----></div></div></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ec2d5af2.js" defer></script><script src="/assets/js/3.e9bff2d3.js" defer></script><script src="/assets/js/11.0a8c3a3b.js" defer></script>
  </body>
</html>
