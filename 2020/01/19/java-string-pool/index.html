<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java字符串池，你懂吗？ | NeroBlackstone&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.efb332ed.css" as="style"><link rel="preload" href="/assets/js/app.ec2d5af2.js" as="script"><link rel="preload" href="/assets/js/3.e9bff2d3.js" as="script"><link rel="preload" href="/assets/js/27.211a8f61.js" as="script"><link rel="prefetch" href="/assets/js/10.7e730691.js"><link rel="prefetch" href="/assets/js/11.0a8c3a3b.js"><link rel="prefetch" href="/assets/js/12.e41009b6.js"><link rel="prefetch" href="/assets/js/13.615800ed.js"><link rel="prefetch" href="/assets/js/14.9ff2a10b.js"><link rel="prefetch" href="/assets/js/15.c0f3d8e0.js"><link rel="prefetch" href="/assets/js/16.267a81c0.js"><link rel="prefetch" href="/assets/js/17.85b26636.js"><link rel="prefetch" href="/assets/js/18.1172ae07.js"><link rel="prefetch" href="/assets/js/19.02da22ed.js"><link rel="prefetch" href="/assets/js/20.899cfc38.js"><link rel="prefetch" href="/assets/js/21.48a7b777.js"><link rel="prefetch" href="/assets/js/22.ae905edc.js"><link rel="prefetch" href="/assets/js/23.145304b2.js"><link rel="prefetch" href="/assets/js/24.fc9aa772.js"><link rel="prefetch" href="/assets/js/25.5370690c.js"><link rel="prefetch" href="/assets/js/26.4092c0ff.js"><link rel="prefetch" href="/assets/js/28.7b4de4b7.js"><link rel="prefetch" href="/assets/js/29.443848ae.js"><link rel="prefetch" href="/assets/js/30.8fb8f839.js"><link rel="prefetch" href="/assets/js/31.39c4255a.js"><link rel="prefetch" href="/assets/js/32.6e0fb50b.js"><link rel="prefetch" href="/assets/js/33.919f59b2.js"><link rel="prefetch" href="/assets/js/34.2fd50063.js"><link rel="prefetch" href="/assets/js/35.3dfac06e.js"><link rel="prefetch" href="/assets/js/36.a873c79a.js"><link rel="prefetch" href="/assets/js/37.85faec35.js"><link rel="prefetch" href="/assets/js/38.e83fe327.js"><link rel="prefetch" href="/assets/js/39.6be1856f.js"><link rel="prefetch" href="/assets/js/4.78206645.js"><link rel="prefetch" href="/assets/js/40.93ddf935.js"><link rel="prefetch" href="/assets/js/41.88d92bf1.js"><link rel="prefetch" href="/assets/js/42.b3d6f88b.js"><link rel="prefetch" href="/assets/js/43.1c5dc4d4.js"><link rel="prefetch" href="/assets/js/44.195f887c.js"><link rel="prefetch" href="/assets/js/45.9aec365f.js"><link rel="prefetch" href="/assets/js/46.a1714c92.js"><link rel="prefetch" href="/assets/js/47.07f6e748.js"><link rel="prefetch" href="/assets/js/48.edfe58e7.js"><link rel="prefetch" href="/assets/js/5.290e8a5b.js"><link rel="prefetch" href="/assets/js/6.0be4f557.js"><link rel="prefetch" href="/assets/js/7.df8bc73d.js"><link rel="prefetch" href="/assets/js/8.9882d415.js"><link rel="prefetch" href="/assets/js/9.62493693.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.07834b74.js">
    <link rel="stylesheet" href="/assets/css/0.styles.efb332ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout"><nav role="navigation" aria-label="main navigation" class="navbar is-primary is-fixed-top"><div class="navbar-brand"><a href="/" to="/" class="navbar-item router-link-active">
        NeroBlackstone's Blog
    </a><a role="button" aria-label="menu" class="navbar-burger burger"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-start"></div><div class="navbar-end"><a href="/tag/" to="/tag/" class="navbar-item">Tag</a> <a href="/friends/" to="/friends/" class="navbar-item">Friends</a></div></div></nav> <section class="section"><div class="container"><div class="content__default"><h1 id="java字符串池，你懂吗？"><a href="#java字符串池，你懂吗？" class="header-anchor">#</a> Java字符串池，你懂吗？</h1> <p>String应该是我们在java里用过最多的类了。在这篇文章中，将讨论java的字符串池(String Pool)————<strong>这是一块特殊的内存区域，JVM用其存储字符串。</strong></p> <h2 id="字符串驻留-string-interning"><a href="#字符串驻留-string-interning" class="header-anchor">#</a> 字符串驻留(String Interning)</h2> <p>由于字符串在java中的不变性，JVM可以通过<strong>在池中仅存储一份每个字符串的拷贝</strong> 来优化内存分配。这个过程就叫做<em>驻留(literning)</em> 。</p> <p>当创建并且给一个<em>String</em> 变量赋值时，JVM会在池里搜索等值的<em>String</em> 。</p> <p><strong>如果找到，Java编译器将直接返回到这个内存地址的引用，而不再分配额外的内存。</strong> 如果未找到，字符串将会填加到池中，然后返回它的引用。</p> <p>写一段kotlin代码验证一下：</p> <blockquote><p>要使用assert函数必须打开JVM的<code>-ea</code>选项</p></blockquote> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> constantString1 <span class="token operator">=</span> <span class="token string">&quot;NeroBlackstone&quot;</span>
<span class="token keyword">val</span> constantString2 <span class="token operator">=</span> <span class="token string">&quot;NeroBlackstone&quot;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>constantString1<span class="token operator">===</span>constantString2<span class="token punctuation">)</span>
</code></pre></div><p>可以发现没有抛出<code>java.lang.AssertionError</code>异常，说明指向的是同一地址。</p> <h2 id="使用构造函数分配字符串"><a href="#使用构造函数分配字符串" class="header-anchor">#</a> 使用构造函数分配字符串</h2> <p>当使用构造函数创建字符串时，编译器将创建新的对象，并且将其存储到JVM的堆中。每个通过构造函数创建的字符串都会指向不同的内存区域，故有不同的地址。</p> <p>看一下和上面有和不同：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> constantString1 <span class="token operator">=</span> <span class="token string">&quot;ABC&quot;</span>
<span class="token keyword">val</span> charArray<span class="token operator">=</span><span class="token function">charArrayOf</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> constantString2 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>charArray<span class="token punctuation">)</span>
<span class="token function">assert</span><span class="token punctuation">(</span>constantString1<span class="token operator">===</span>constantString2<span class="token punctuation">)</span>
</code></pre></div><p>这次抛出了<code>java.lang.AssertionError</code>异常。</p> <h2 id="字符串字面量和字符串对象"><a href="#字符串字面量和字符串对象" class="header-anchor">#</a> 字符串字面量和字符串对象</h2> <p><strong>当我们使用构造函数创建字符串对象时，它总是要在堆中创建新对象。而与之相对，如果直接用字符串字面量创建一个对象，如果其在字符串池中已经存在，会直接从池中返回。</strong> 否则将创建一个新的字符串对象，并且放入字符串池以备将来使用。</p> <p>从顶层上看，都只是字符串对象，主要的区别在构造函数总是创建一个新对象，而使用字面量创建字符串，会优先使用驻留的对象。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> charArray<span class="token operator">=</span><span class="token function">charArrayOf</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> constantString1 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>charArray<span class="token punctuation">)</span>
<span class="token keyword">val</span> constantString2 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>charArray<span class="token punctuation">)</span>
<span class="token function">assert</span><span class="token punctuation">(</span>constantString1<span class="token operator">===</span>constantString2<span class="token punctuation">)</span>
</code></pre></div><p>抛出了<code>java.lang.AssertionError</code>异常，可以看出使用构造函数的话会是两个不同的地址。</p> <p><strong>一般来说应尽可能使用字面量的创建方法。</strong> 它更加易于阅读并且让编译器更容易优化代码。</p> <h2 id="手动驻留"><a href="#手动驻留" class="header-anchor">#</a> 手动驻留</h2> <p>其实我们可以通过在字符串对象上调用intern()函数手动将其驻留到池中。手动驻留字符串将会把它的引用存到池中，如果再需要JVM会返回这个引用。</p> <p>比如像这样：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> charArray<span class="token operator">=</span><span class="token function">charArrayOf</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> constantString1 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>charArray<span class="token punctuation">)</span>
<span class="token keyword">val</span> constantString2 <span class="token operator">=</span> constantString1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">assert</span><span class="token punctuation">(</span>constantString1<span class="token operator">===</span>constantString2<span class="token punctuation">)</span>
</code></pre></div><p>并不丢出<code>java.lang.AssertionError</code>异常,地址相等。</p> <h2 id="java9新特性"><a href="#java9新特性" class="header-anchor">#</a> java9新特性</h2> <p>java8时代，字符串在底层表示为字符串数组<em>char[]</em>，使用<em>UTF-16</em>编码，每个字符占用两个字节。</p> <p>到了java9以后提供了一种新的表示方法，叫做<em>紧凑字符串(Compact Strings)</em> 。这种新格式将根据存储内容，在<em>char[]</em> 和 <em>byte[]</em> 间选择正确的编码。</p> <p>由于新的紧凑字符串只在需要时才使用<em>UTF-16</em> ，因此堆内存的大小将会显著降低，也意味着GC开销会更小。</p> <p>这是一个默认启用并实现的功能，你无需任何调整就能享受到新的优化。</p></div> <!----></div></section> <footer class="footer" data-v-29777868><div class="level" data-v-29777868><div class="content level-item has-text-centered" data-v-29777868><div class="field is-grouped-multiline is-grouped" data-v-29777868><!----> <div class="control" data-v-29777868><span class="tag is-primary" data-v-29777868><span><a href="https://github.com/NeroBlackstone" class="has-text-white" data-v-29777868><span class="icon" data-v-29777868><i class="fab fa-github" data-v-29777868></i></span></a></span> <!----></span></div> <div class="control" data-v-29777868><a href="https://v1.vuepress.vuejs.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>vuepress</span> <!----></span> <span class="tag is-info" data-v-29777868><span>1.5.0</span> <!----></span></div></a></div><div class="control" data-v-29777868><a href="https://buefy.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>buefy</span> <!----></span> <span class="tag is-info" data-v-29777868><span>0.8.20</span> <!----></span></div></a></div> <!----></div></div></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ec2d5af2.js" defer></script><script src="/assets/js/3.e9bff2d3.js" defer></script><script src="/assets/js/27.211a8f61.js" defer></script>
  </body>
</html>
