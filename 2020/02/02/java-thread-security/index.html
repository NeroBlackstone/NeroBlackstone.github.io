<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线程安全到底是什么 | NeroBlackstone&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.efb332ed.css" as="style"><link rel="preload" href="/assets/js/app.ec2d5af2.js" as="script"><link rel="preload" href="/assets/js/3.e9bff2d3.js" as="script"><link rel="preload" href="/assets/js/39.6be1856f.js" as="script"><link rel="prefetch" href="/assets/js/10.7e730691.js"><link rel="prefetch" href="/assets/js/11.0a8c3a3b.js"><link rel="prefetch" href="/assets/js/12.e41009b6.js"><link rel="prefetch" href="/assets/js/13.615800ed.js"><link rel="prefetch" href="/assets/js/14.9ff2a10b.js"><link rel="prefetch" href="/assets/js/15.c0f3d8e0.js"><link rel="prefetch" href="/assets/js/16.267a81c0.js"><link rel="prefetch" href="/assets/js/17.85b26636.js"><link rel="prefetch" href="/assets/js/18.1172ae07.js"><link rel="prefetch" href="/assets/js/19.02da22ed.js"><link rel="prefetch" href="/assets/js/20.899cfc38.js"><link rel="prefetch" href="/assets/js/21.48a7b777.js"><link rel="prefetch" href="/assets/js/22.ae905edc.js"><link rel="prefetch" href="/assets/js/23.145304b2.js"><link rel="prefetch" href="/assets/js/24.fc9aa772.js"><link rel="prefetch" href="/assets/js/25.5370690c.js"><link rel="prefetch" href="/assets/js/26.4092c0ff.js"><link rel="prefetch" href="/assets/js/27.211a8f61.js"><link rel="prefetch" href="/assets/js/28.7b4de4b7.js"><link rel="prefetch" href="/assets/js/29.443848ae.js"><link rel="prefetch" href="/assets/js/30.8fb8f839.js"><link rel="prefetch" href="/assets/js/31.39c4255a.js"><link rel="prefetch" href="/assets/js/32.6e0fb50b.js"><link rel="prefetch" href="/assets/js/33.919f59b2.js"><link rel="prefetch" href="/assets/js/34.2fd50063.js"><link rel="prefetch" href="/assets/js/35.3dfac06e.js"><link rel="prefetch" href="/assets/js/36.a873c79a.js"><link rel="prefetch" href="/assets/js/37.85faec35.js"><link rel="prefetch" href="/assets/js/38.e83fe327.js"><link rel="prefetch" href="/assets/js/4.78206645.js"><link rel="prefetch" href="/assets/js/40.93ddf935.js"><link rel="prefetch" href="/assets/js/41.88d92bf1.js"><link rel="prefetch" href="/assets/js/42.b3d6f88b.js"><link rel="prefetch" href="/assets/js/43.1c5dc4d4.js"><link rel="prefetch" href="/assets/js/44.195f887c.js"><link rel="prefetch" href="/assets/js/45.9aec365f.js"><link rel="prefetch" href="/assets/js/46.a1714c92.js"><link rel="prefetch" href="/assets/js/47.07f6e748.js"><link rel="prefetch" href="/assets/js/48.edfe58e7.js"><link rel="prefetch" href="/assets/js/5.290e8a5b.js"><link rel="prefetch" href="/assets/js/6.0be4f557.js"><link rel="prefetch" href="/assets/js/7.df8bc73d.js"><link rel="prefetch" href="/assets/js/8.9882d415.js"><link rel="prefetch" href="/assets/js/9.62493693.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.07834b74.js">
    <link rel="stylesheet" href="/assets/css/0.styles.efb332ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout"><nav role="navigation" aria-label="main navigation" class="navbar is-primary is-fixed-top"><div class="navbar-brand"><a href="/" to="/" class="navbar-item router-link-active">
        NeroBlackstone's Blog
    </a><a role="button" aria-label="menu" class="navbar-burger burger"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-start"></div><div class="navbar-end"><a href="/tag/" to="/tag/" class="navbar-item">Tag</a> <a href="/friends/" to="/friends/" class="navbar-item">Friends</a></div></div></nav> <section class="section"><div class="container"><div class="content__default"><h1 id="线程安全到底是什么"><a href="#线程安全到底是什么" class="header-anchor">#</a> 线程安全到底是什么</h1> <p>java/kotlin提供开箱即用的多线程支持，（kotlin还支持协程）。jvm可以通过在多个工作线程中分别运行字节码，提升程序性能。</p> <p>多线程是一个强大而又麻烦的特性。在多线程环境中我们需要编写线程安全的代码。不同的线程可以同时访问相同的资源，而不发生一些意料之外的错误。</p> <p>本文将讨论几种线程安全的实现方法。（我全写kotlin代码，java读者可以照着感觉理解）</p> <h2 id="无状态实现"><a href="#无状态实现" class="header-anchor">#</a> 无状态实现</h2> <p>在大多数情况下，多线程程序中的错误，是线程间不正确分享状态的恶果。所以干脆使用<strong>无状态</strong> 来实现线程安全。为了更好的理解，假设现在有一个简单的计算阶乘的单例工具类：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">object</span> MathUtils <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> BigInteger <span class="token punctuation">{</span>
        <span class="token keyword">var</span> f<span class="token operator">=</span><span class="token function">BigInteger</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">{</span>
            f<span class="token operator">=</span>f<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>BigInteger<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">(</span>it<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> f
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>factorial()函数就是一个无状态确定性函数。</strong> 给特定的输入，总是产生相同的输出。</p> <p>该方法<strong>既不依赖外部状态，也不维护状态</strong> 。因此，这就是一个线程安全的函数，可以同时被多个线程安全的调用。</p> <p>所有的线程都可以安全地调用factorial()函数，函数将会返回预期的结果而不会彼此干扰，并且不需要明示这个输出是其他线程产生的。</p> <p>因此，<strong>无状态是实现线程安全的最简单的方法</strong> 。</p> <h2 id="不可变实现"><a href="#不可变实现" class="header-anchor">#</a> 不可变实现</h2> <p><strong>不变性也是实现线程安全的方法之一。</strong></p> <p><strong>如果我们需要在不同的线程间分享状态，我们可以通过使它们不可变来创建线程安全的类。</strong> 不变性是一个强大且与语言无关的概念，在kotlin中很容易实现。</p> <p>简单来说，<strong>一个不可变类的实例的内部状态，在它被构造出来以后无法修改</strong> 。在kotlin中创建不可变类的最简单方法是将所有数据域的数据声明为private和val。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">MessageService</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> message<span class="token operator">:</span> String<span class="token punctuation">)</span>
</code></pre></div><p>MessageService对象是不可变的，因为它的状态在构造后便不能改变。因此它也是线程安全的。如果MessageService是可变的，但是每个线程对它都是只读的，那么它也是线程安全的。</p> <h2 id="线程局部字段"><a href="#线程局部字段" class="header-anchor">#</a> 线程局部字段</h2> <p>在oop中，对象需要通过字段和行为（类里的方法）维持状态。如果我们只需要维持状态，<strong>通过将其字段置为线程局部，不分享其状态，就可以创建线程安全的类。</strong></p> <p>通过在Thread类里定义私有字段，就可以创建线程局部的字段。</p> <p>例如，我们可以定义一个存储整数的数组：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> ThreadA <span class="token operator">:</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> numbers <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者是一个存字符串的数组：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> ThreadB <span class="token operator">:</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> letters <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;e&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;f&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> letters<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>在这两种实现中，这些类都有自己的状态，但是不与其他线程共享。因此都是线程安全的。</strong></p> <p>同样的，把ThreadLocal实例分配到字段中也可以创建线程局部的字段。</p> <p>举个例子，有下面的StateHolder类：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> StateHolder <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> state<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token comment">// standard constructors / getter</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">object</span> ThreadState <span class="token punctuation">{</span>
    <span class="token keyword">val</span> statePerThread<span class="token operator">:</span> ThreadLocal<span class="token operator">&lt;</span>StateHolder<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> ThreadLocal<span class="token operator">&lt;</span>StateHolder<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">StateHolder</span><span class="token punctuation">(</span><span class="token string">&quot;active&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">val</span> state<span class="token operator">:</span> StateHolder
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> statePerThread<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>线程局部字段很像普通的类字段，但是每个通过getter/setter访问它们的线程会获得一个独立初始化的字段副本，所以每个线程都保有自身单独的字段。</p> <h2 id="同步集合（synchronized-collections）"><a href="#同步集合（synchronized-collections）" class="header-anchor">#</a> 同步集合（Synchronized Collections）</h2> <p>我们可以通过使用集合类中的一组同步包装器来创建线程安全的集合：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> syncCollection <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedCollection</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">thread</span><span class="token punctuation">(</span>start <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    syncCollection<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">thread</span><span class="token punctuation">(</span>start <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    syncCollection<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同步集合中每个方法都使用了（intrinsic locking）固有锁定。<strong>这意味着该方法只可以被单独一个线程访问，而其他线程将被阻塞，直到第一个线程解锁为止。</strong></p> <p>但是由于同步访问的基本逻辑，同步集合的性能会比较低。</p> <h2 id="并发集合（concurrent-collections）"><a href="#并发集合（concurrent-collections）" class="header-anchor">#</a> 并发集合（Concurrent Collections）</h2> <p>除了同步集合，还可以使用并发集合来创建线程安全的集合。java提供了java.util.concurrent包，包含了ConcurrentHashMap等多个并发集合。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> concurrentMap<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
concurrentMap<span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;one&quot;</span>
concurrentMap<span class="token punctuation">[</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;two&quot;</span>
concurrentMap<span class="token punctuation">[</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;three&quot;</span>
</code></pre></div><p>与同步集合不同，<strong>并发集合通过将数据分割为段来达到线程安全的目的。</strong> 举个例子，在ConcurrentHashMap中，多个线程可以取得不同映射段上的锁，因此多个线程可以同时访问映射。</p> <p>由于并发集合内部线程并发访问的优势，<strong>相较于同步集合，并发集合性能更加优秀。</strong> 另外，同步集合和并发集合仅使集合本身具有线程安全性，而非集合内容。</p> <h2 id="原子对象（atomic-objects）"><a href="#原子对象（atomic-objects）" class="header-anchor">#</a> 原子对象（Atomic Objects）</h2> <p>使用java提供的一组原子类，也可以实现线程安全。（包括AtomicInteger, AtomicLong, AtomicBoolean, and AtomicReference.）</p> <p><strong>原子类允许我们执行线程安全的原子操作，而无需使用同步。</strong> 原子操作在单个机器级别的操作中执行。</p> <p>看一个Counter类的实例：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">private</span> <span class="token keyword">set</span>
    <span class="token keyword">fun</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>假设在竞争条件下，两个线程同时访问incrementCounter()方法。</strong> 从理论上讲，Counter的最终值为2。但是结果是不确定的，因为线程在同一时间执行统一代码块，并且增量是不原子的。</p> <p>可以使用AtomicInterger实现类型安全的Counter:</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> AtomicCounter <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> counter <span class="token operator">=</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> counter<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span>counter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>这下就是线程安全的了，同时自增会执行多个操作，incrementAndGet是原子的。</strong></p> <h2 id="同步方法"><a href="#同步方法" class="header-anchor">#</a> 同步方法</h2> <p>尽管前面的方法很适合在集合或是原始类型上使用，但是有时候会需要更高的控制权。这时另一个用于实现线程安全的方法是实现同步方法。</p> <p>简而言之，<strong>一次只有一条线程可以访问同步方法，同时阻止其他线程对该方法的访问。</strong> 其他线程将会保持阻塞状态，直到第一个线程结束或是方法抛出异常。</p> <p>可以通过将方法转为同步方法来创建线程安全的incrementCounter()：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token annotation builtin">@Synchronized</span>
<span class="token keyword">fun</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counter <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以在函数上加上@Synchronize来创建一个同步方法。由于一条线程一次只可以访问一个同步方法，其他线程将会等待，不会有重叠的执行发生。</p> <p><strong>同步方法依赖于“内在锁”（或叫“监视锁”）（“intrinsic locks” or “monitor locks”）的使用。</strong> 内在锁是一个与特定类实例相关联的隐式内部实体。</p> <p>在多线程这个上下文中，监视器（monitor）这个名词，只是锁在关联对象上角色的引申，因为它强制独占访问一系列特定方法或语句。</p> <p><strong>当线程调用一个同步方法，它就获取了内在锁。</strong> 线程完成方法执行后，它会释放锁，允许其他线程取得锁并且访问这个方法。我们可以在实例方法，静态方法，和代码块中实现同步。</p> <h2 id="同步语句"><a href="#同步语句" class="header-anchor">#</a> 同步语句</h2> <p>有时，如果只需要使方法内的一段语句线程安全，那么同步整个方法就显得多余。例如我们可以这样重构 incrementCounter() 方法：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// additional unsynced operations</span>
    <span class="token function">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter <span class="token operator">+=</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个例子简单地演示了如何创建同步语句。假设该方法现在执行了一些其他不需要同步的操作，我们可以通过将代码包裹在synchronized，来仅仅同步有关状态修改的部分。</p> <p><strong>同步性能开销非常大，我们可以仅仅同步需要同步的部分。</strong></p> <h2 id="volatile域"><a href="#volatile域" class="header-anchor">#</a> volatile域</h2> <blockquote><p>在看下面的内容前可参考<a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener noreferrer">Java中Volatile关键字详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>同步方法和同步代码块非常适合解决线程间的变量可见性问题。即使这样，常规类字段的值也会被cpu缓存。因此，对特定字段的后续更新，即使已经同步，也可能对其他线程不可见。</p> <p>要防止这种情况，可以使用volatile标签：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> Counter <span class="token punctuation">{</span>
    <span class="token annotation builtin">@Volatile</span>
    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">private</span> <span class="token keyword">set</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>加上volatile标签后，会指示JVM和编译器去存储一个counter变量到主内存中。</strong> 这样可以确保每次jvm读取counter的值是从主内存中读取的，而非cpu缓存。每次jvm写入counter变量值时，这个变量也将写入主内存。</p> <p><strong>使用volatile标签可以确保对所有线程来说变量可见，并且变量总是从主内存中读取。</strong></p> <p>思考下面的例子：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> User <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">private</span> <span class="token keyword">set</span>
    <span class="token annotation builtin">@Volatile</span>
    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">private</span> <span class="token keyword">set</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这种情况下，每次JVM都将写入age volatile变量到主内存中，也会将name这个non-volatile变量写入内存。这确保了最新的变量都存在主内存中，所以对变量的后续更新将会自动对其余线程可见。</p> <p>同样，如果线程读取volatile变量，所有的可见变量也将从主内存中读取。</p> <p><strong>volatile变量提供的这种扩展的保证被称为&quot;full volatile visibility guarantee.&quot;</strong></p> <h2 id="外置锁"><a href="#外置锁" class="header-anchor">#</a> 外置锁</h2> <p>使用外置锁（Extrinsic Locking）而不是内置锁，可以稍微改善前面Counter类的线程安全实现。外置锁提供了多线程环境中对共享资源的协调访问，<strong>它使用外部实体来强制独占访问资源。</strong></p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> ExtrinsicLockCounter <span class="token punctuation">{</span>
    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">private</span> <span class="token keyword">set</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> lock <span class="token operator">=</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span> counter <span class="token operator">+=</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里使用一个简单的Any实例来创建外置锁。这个实现稍微好一点，因为它提高了锁等级的安全性。</p> <p>使用内置锁的话，同步方法和同步代码块依赖于this引用，<strong>攻击者可以通过获取内部锁并且触发拒绝服务（dos）条件来引发死锁。</strong></p> <p>不像内置锁，<strong>外置锁使用私有实体，该私有实体不可从外部访问。</strong> 这使得攻击者更难获得锁，并导致死锁。</p> <blockquote><p>关于这个问题可以参阅SOF回答<a href="https://stackoverflow.com/questions/19419702/what-is-the-use-of-private-final-object-locking-in-java-multithreading" target="_blank" rel="noopener noreferrer">what-is-the-use-of-private-final-object-locking-in-java-multithreading<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，没有任何中文资料提到这个问题。</p></blockquote> <h2 id="重入锁"><a href="#重入锁" class="header-anchor">#</a> 重入锁</h2> <p>java提供了一组改进过的锁实现，其行为比上面讨论的内置锁稍微复杂一点。</p> <p><strong>对于内置锁，锁的获取模型非常严格：</strong> 一个线程获取锁，然后执行一个方法或代码块，最后释放，其余线程才可以获取它并且访问该方法。</p> <p>没有底层机制来检查排队的线程，好让等待时间最长的线程优先访问。重入锁（ReentrantLock）实例可以解决这个问题，防止入队的线程因为某种程度的资源缺乏而无法执行：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> ReentrantLockCounter <span class="token punctuation">{</span>
    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">private</span> <span class="token keyword">set</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> reLock <span class="token operator">=</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        reLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        counter <span class="token operator">+=</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token number">1</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            reLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>重入锁的构造函数有一个可选的布尔变量。当设置为true，且多个进程正在尝试获取锁时，jvm将会优先考虑等待时间最长的线程并且赋予访问锁的权限。</p> <h2 id="读-写锁"><a href="#读-写锁" class="header-anchor">#</a> 读/写锁</h2> <p>我们还可以用读写锁（ReadWriteLock）来实现线程安全。读写锁实际上使用了一对相关联的锁，一个用于只读操作，另一个用于写操作。</p> <p><strong>只要没有线程写入，就可以有很多线程读取资源。此外，将线程写入资源将阻止其他线程读取资源。</strong></p> <p>我们可以这样使用ReadWriteLock锁：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> ReentrantReadWriteLockCounter <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> rwLock <span class="token operator">=</span> <span class="token function">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> readLock<span class="token operator">:</span> Lock <span class="token operator">=</span> rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> writeLock<span class="token operator">:</span> Lock <span class="token operator">=</span> rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        counter <span class="token operator">+=</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token number">1</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            writeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">fun</span> <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
        readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>
            counter
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre></div></div> <!----></div></section> <footer class="footer" data-v-29777868><div class="level" data-v-29777868><div class="content level-item has-text-centered" data-v-29777868><div class="field is-grouped-multiline is-grouped" data-v-29777868><!----> <div class="control" data-v-29777868><span class="tag is-primary" data-v-29777868><span><a href="https://github.com/NeroBlackstone" class="has-text-white" data-v-29777868><span class="icon" data-v-29777868><i class="fab fa-github" data-v-29777868></i></span></a></span> <!----></span></div> <div class="control" data-v-29777868><a href="https://v1.vuepress.vuejs.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>vuepress</span> <!----></span> <span class="tag is-info" data-v-29777868><span>1.5.0</span> <!----></span></div></a></div><div class="control" data-v-29777868><a href="https://buefy.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>buefy</span> <!----></span> <span class="tag is-info" data-v-29777868><span>0.8.20</span> <!----></span></div></a></div> <!----></div></div></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ec2d5af2.js" defer></script><script src="/assets/js/3.e9bff2d3.js" defer></script><script src="/assets/js/39.6be1856f.js" defer></script>
  </body>
</html>
