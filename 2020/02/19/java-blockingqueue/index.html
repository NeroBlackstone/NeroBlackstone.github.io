<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>java BlockingQueue简介 | NeroBlackstone&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.efb332ed.css" as="style"><link rel="preload" href="/assets/js/app.ec2d5af2.js" as="script"><link rel="preload" href="/assets/js/3.e9bff2d3.js" as="script"><link rel="preload" href="/assets/js/38.e83fe327.js" as="script"><link rel="prefetch" href="/assets/js/10.7e730691.js"><link rel="prefetch" href="/assets/js/11.0a8c3a3b.js"><link rel="prefetch" href="/assets/js/12.e41009b6.js"><link rel="prefetch" href="/assets/js/13.615800ed.js"><link rel="prefetch" href="/assets/js/14.9ff2a10b.js"><link rel="prefetch" href="/assets/js/15.c0f3d8e0.js"><link rel="prefetch" href="/assets/js/16.267a81c0.js"><link rel="prefetch" href="/assets/js/17.85b26636.js"><link rel="prefetch" href="/assets/js/18.1172ae07.js"><link rel="prefetch" href="/assets/js/19.02da22ed.js"><link rel="prefetch" href="/assets/js/20.899cfc38.js"><link rel="prefetch" href="/assets/js/21.48a7b777.js"><link rel="prefetch" href="/assets/js/22.ae905edc.js"><link rel="prefetch" href="/assets/js/23.145304b2.js"><link rel="prefetch" href="/assets/js/24.fc9aa772.js"><link rel="prefetch" href="/assets/js/25.5370690c.js"><link rel="prefetch" href="/assets/js/26.4092c0ff.js"><link rel="prefetch" href="/assets/js/27.211a8f61.js"><link rel="prefetch" href="/assets/js/28.7b4de4b7.js"><link rel="prefetch" href="/assets/js/29.443848ae.js"><link rel="prefetch" href="/assets/js/30.8fb8f839.js"><link rel="prefetch" href="/assets/js/31.39c4255a.js"><link rel="prefetch" href="/assets/js/32.6e0fb50b.js"><link rel="prefetch" href="/assets/js/33.919f59b2.js"><link rel="prefetch" href="/assets/js/34.2fd50063.js"><link rel="prefetch" href="/assets/js/35.3dfac06e.js"><link rel="prefetch" href="/assets/js/36.a873c79a.js"><link rel="prefetch" href="/assets/js/37.85faec35.js"><link rel="prefetch" href="/assets/js/39.6be1856f.js"><link rel="prefetch" href="/assets/js/4.78206645.js"><link rel="prefetch" href="/assets/js/40.93ddf935.js"><link rel="prefetch" href="/assets/js/41.88d92bf1.js"><link rel="prefetch" href="/assets/js/42.b3d6f88b.js"><link rel="prefetch" href="/assets/js/43.1c5dc4d4.js"><link rel="prefetch" href="/assets/js/44.195f887c.js"><link rel="prefetch" href="/assets/js/45.9aec365f.js"><link rel="prefetch" href="/assets/js/46.a1714c92.js"><link rel="prefetch" href="/assets/js/47.07f6e748.js"><link rel="prefetch" href="/assets/js/48.edfe58e7.js"><link rel="prefetch" href="/assets/js/5.290e8a5b.js"><link rel="prefetch" href="/assets/js/6.0be4f557.js"><link rel="prefetch" href="/assets/js/7.df8bc73d.js"><link rel="prefetch" href="/assets/js/8.9882d415.js"><link rel="prefetch" href="/assets/js/9.62493693.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.07834b74.js">
    <link rel="stylesheet" href="/assets/css/0.styles.efb332ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout"><nav role="navigation" aria-label="main navigation" class="navbar is-primary is-fixed-top"><div class="navbar-brand"><a href="/" to="/" class="navbar-item router-link-active">
        NeroBlackstone's Blog
    </a><a role="button" aria-label="menu" class="navbar-burger burger"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-start"></div><div class="navbar-end"><a href="/tag/" to="/tag/" class="navbar-item">Tag</a> <a href="/friends/" to="/friends/" class="navbar-item">Friends</a></div></div></nav> <section class="section"><div class="container"><div class="content__default"><h1 id="java-blockingqueue简介"><a href="#java-blockingqueue简介" class="header-anchor">#</a> java BlockingQueue简介</h1> <p>在这篇文章中，会介绍如何使用BlockingQueue来解决并发当中的生产者-消费者问题。我们将研究BlockingQueue接口中提供的api，以及这些api如何简化并发编程。</p> <p>接下来将展示一个简单的程序示例，有多个生产者和消费者线程。</p> <h2 id="blockingqueue类型"><a href="#blockingqueue类型" class="header-anchor">#</a> BlockingQueue类型</h2> <p>BlockingQueue有两种类型：</p> <ul><li>无界队列(unbounded queue) 可以近乎无限增长</li> <li>有界队列（bounded queue） 有预定义的最大容量</li></ul> <h3 id="无界队列"><a href="#无界队列" class="header-anchor">#</a> 无界队列</h3> <p>创建无界队列非常简单：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> blockingQueue <span class="token operator">=</span> LinkedBlockingDeque<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>这样BlockingQueue的容量将被设为<em>Int.MAX_VALUE</em> 。所有将元素添加到无界队列的操作都不会被阻塞，因此队列可能会增长到非常大的值。</p> <p>当设计一个使用无界BlockingQueue的生产者-消费者程序时，最重要的事情，是消费者消费信息的速度，能够尽可能跟上生产者添加消息到队列的速度。不然内存可能会溢出，抛出OutOfMemory异常。</p> <h3 id="有界队列"><a href="#有界队列" class="header-anchor">#</a> 有界队列</h3> <p>第二种队列类型是有界队列。可以通过给构造方法传入容量参数来创建此队列：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> blockingQueue<span class="token operator">=</span> LinkedBlockingDeque<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre></div><p>在这里实例化了一个容量为10的blockingQueue。这意味着如果生产者尝试添加元素到已满队列时，它将保持阻塞，直到有空间可以插入对象。或是直接操作失败。（这取决于用什么方法添加元素，offer(), add() 还是 put()）。</p> <p>使用有界队列来设计并发程序是比较好的选择，因为我们插入元素到已满队列的话，插入需要等到消费者消费掉队列元素，并且队列有可用空间以后才能进行。相当于自动的达到了拥塞控制。</p> <h2 id="blockingqueue-api"><a href="#blockingqueue-api" class="header-anchor">#</a> BlockingQueue API</h2> <p>BlockingQueue接口里定义了两种方法，负责添加元素到队列中的方法，和检索元素的方法。根据队列是满还是空，这两类方法的行为也不同。</p> <h3 id="添加元素"><a href="#添加元素" class="header-anchor">#</a> 添加元素</h3> <ul><li>add() 如果插入成功返回true，否则抛出一个IllegalStateException异常</li> <li>put() 插入指定的元素到队列中，如果需要的话，会等待可用的空间。</li> <li>offer() 如果插入成功返回true，否则返回false</li> <li>offer(E e, long timeout, TimeUnit unit) 在指定的时间内，尝试将元素插入队列并且等待可用的空间</li></ul> <h3 id="检索元素"><a href="#检索元素" class="header-anchor">#</a> 检索元素</h3> <ul><li>take() 等待队列的头元素，并且移除它。如果队列为空，它会阻塞并等待可用的元素。</li> <li>poll() 检索并且移除队列的头元素，如果需要，等待指定的等待时间，直到有元素可用。超时返回null。</li></ul> <p>在构建生产者-消费者程序时，BlockingQueue接口中的这些方法使用非常频繁。</p> <h2 id="多线程生产者-消费者示例"><a href="#多线程生产者-消费者示例" class="header-anchor">#</a> 多线程生产者-消费者示例</h2> <p>创建一个包含生产者和消费者的程序。生产者将产生0到100的随机数，并且放入BlockingQueue中。我们设计4个生产者线程，使用put()方法来达到阻塞效果，直到队列中有可用空间为止。</p> <p>需要记住的最重要的一点，我们需要永久停止等待队列元素的消费者线程。</p> <p>生产者向消费者发送“没有更多消息需要处理了”信号的最好办法，是发生称为“毒丸”（poison pill）的特殊消息。我们需要发送和消费者线程数量相同的“毒丸”。当一个消费者从队列中接受了特殊的“毒丸”信息，就会停止执行。</p> <p>生产者类是这样的：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">NumbersProducer</span><span class="token punctuation">(</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> numbersQueue<span class="token operator">:</span> BlockingQueue<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> poisonPill<span class="token operator">:</span> Int<span class="token punctuation">,</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> poisonPillPerProducer<span class="token operator">:</span> Int
<span class="token punctuation">)</span> <span class="token operator">:</span> Runnable <span class="token punctuation">{</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">generateNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> InterruptedException<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token annotation builtin">@Throws</span><span class="token punctuation">(</span>InterruptedException<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">generateNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            numbersQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span>poisonPillPerProducer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            numbersQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>poisonPill<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们的生产者构造函数接受一个BlockingQueue作为参数，用于协调生产者和消费者。可以看到generateNumbers()方法将100个元素放入队列。同样放入的还有“毒丸”信息，这定义了当执行即将结束时，消费者会拿到消息的类型。该消息需要放入poisonPillPerProducer次。</p> <p>每个消费者都使用take()方法从BlockingQueue中取得元素，因此在队列中有元素送入之前将会阻塞。从队列中拿到Int后，会检查该信息是否为“毒丸”，如果是的话线程直接结束。否则会在标准输出中打印消息结果和当前线程名称。</p> <p>消费者类是这样的：</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">NumbersConsumer</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> queue<span class="token operator">:</span> BlockingQueue<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">private</span> <span class="token keyword">val</span> poisonPill<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">:</span> Runnable <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">val</span> number <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">==</span> poisonPill<span class="token punctuation">)</span> 
                    <span class="token keyword">return</span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;<span class="token interpolation"><span class="token delimiter variable">${</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span> result: <span class="token interpolation variable">$number</span>&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> InterruptedException<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意上面队列的使用，与生产者构造函数相同，会将一个队列作为参数传入。我们之所以可以这样做，是因为BlockingQueue可以在线程间共享，而无需任何显式同步。</p> <p>现在有了生产者和消费者，可以开始写主程序了！我们需要定义队列的容量，并且将其设置为100个元素。我们希望有4个生产者线程，和与处理器核心数量相同的消费者线程。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token keyword">val</span> bound <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">val</span> nPRODUCERS <span class="token operator">=</span> <span class="token number">4</span>
<span class="token keyword">val</span> nCONSUMERS <span class="token operator">=</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> poisonPill <span class="token operator">=</span> Int<span class="token punctuation">.</span>MAX_VALUE
<span class="token keyword">val</span> poisonPillPerProducer <span class="token operator">=</span> nCONSUMERS <span class="token operator">/</span> nPRODUCERS
<span class="token keyword">val</span> mod <span class="token operator">=</span> nCONSUMERS <span class="token operator">%</span> nPRODUCERS

<span class="token keyword">val</span> queue <span class="token operator">=</span> LinkedBlockingQueue<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span>bound<span class="token punctuation">)</span>

<span class="token function">repeat</span><span class="token punctuation">(</span>nPRODUCERS<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//注意这里不能用kotlin的thread包装函数，因为代码块在thread{}内会自动装入Runnable</span>
    <span class="token comment">//而NumberProducer本身就是Runnable，下同</span>
    <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token function">NumbersProducer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> poisonPill<span class="token punctuation">,</span> poisonPillPerProducer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">repeat</span><span class="token punctuation">(</span>nCONSUMERS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token function">NumbersConsumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> poisonPill<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">Thread</span><span class="token punctuation">(</span><span class="token function">NumbersProducer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> poisonPill<span class="token punctuation">,</span> poisonPillPerProducer <span class="token operator">+</span> mod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>BlockingQueue创建时预定义了容量。我们在这里创建了4个生产者和N个消费者。并且将“毒丸”信息设置为Int.MAX_VALUE，因为正常情况下生产者永远不会产生这样的值。BlockingQueue用于协调双方工作。</p> <p>当我们运行程序时，4个生产者线程将会把随机的Int放入到BlockingQueue中，消费者将从队列中取得这些元素。每个消费者线程将在标准输出中打印消息结果和当前线程名称。</p></div> <!----></div></section> <footer class="footer" data-v-29777868><div class="level" data-v-29777868><div class="content level-item has-text-centered" data-v-29777868><div class="field is-grouped-multiline is-grouped" data-v-29777868><!----> <div class="control" data-v-29777868><span class="tag is-primary" data-v-29777868><span><a href="https://github.com/NeroBlackstone" class="has-text-white" data-v-29777868><span class="icon" data-v-29777868><i class="fab fa-github" data-v-29777868></i></span></a></span> <!----></span></div> <div class="control" data-v-29777868><a href="https://v1.vuepress.vuejs.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>vuepress</span> <!----></span> <span class="tag is-info" data-v-29777868><span>1.5.0</span> <!----></span></div></a></div><div class="control" data-v-29777868><a href="https://buefy.org/" data-v-29777868><div class="tags has-addons" data-v-29777868><span class="tag is-dark" data-v-29777868><span>buefy</span> <!----></span> <span class="tag is-info" data-v-29777868><span>0.8.20</span> <!----></span></div></a></div> <!----></div></div></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ec2d5af2.js" defer></script><script src="/assets/js/3.e9bff2d3.js" defer></script><script src="/assets/js/38.e83fe327.js" defer></script>
  </body>
</html>
