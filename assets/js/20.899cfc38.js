(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{376:function(t,a,e){"use strict";e.r(a);var s=e(14),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"一些常见的golang命名-编码规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一些常见的golang命名-编码规范"}},[t._v("#")]),t._v(" 一些常见的Golang命名/编码规范")]),t._v(" "),e("p",[t._v("下列命名规范均求证于官方网站"),e("a",{attrs:{href:"https://golang.org/doc/effective_go.html#package-names",target:"_blank",rel:"noopener noreferrer"}},[t._v("Effective Go"),e("OutboundLink")],1),t._v("\n及"),e("a",{attrs:{href:"https://github.com/golang/go/wiki/CodeReviewComments#package-comments",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方github code review规范"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"包名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包名"}},[t._v("#")]),t._v(" 包名")]),t._v(" "),e("p",[t._v("package使用"),e("strong",[t._v("小写，单个单词")]),t._v(" 的命名。不需要下划线和混合多个单词。")]),t._v(" "),e("p",[t._v("可能有人会担心这样很容易重包名，但是包仅仅是导入的默认名称，在源代码中无需独一无二。如果发生冲突，可以局部的使用另一个命名。")]),t._v(" "),e("p",[e("strong",[t._v("包名需要和存放包源文件的文件夹名相同")]),t._v(' 。在src/encoding/base64中的包以"encoding/base64"的方式导入，包命名为base64, 而不是 encoding_base64或是encodingBase64。')]),t._v(" "),e("h2",{attrs:{id:"包注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包注释"}},[t._v("#")]),t._v(" 包注释")]),t._v(" "),e("p",[t._v("在"),e("strong",[t._v("包名上方必须写一行包注释")]),t._v(" 。中间不能有空行。例如")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Package math provides basic constants and mathematical functions.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" math\n")])])]),e("p",[t._v("main包的包注释，写上其生成的二进制可执行文件名称。例如，对于文件夹"),e("code",[t._v("seedgen")]),t._v("里的main包，可以这样写注释：")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Program seedgen ...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n")])])]),e("p",[t._v("注意：包注释不能是以小写单词开头的句子，因为它是公共可见的，所以要用正确的英文。当二进制可执行文件名是包注释的第一个单词，也必须对其大写，即使cli里的调用和包注释的拼写不一致。")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Seedgen ...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" main\n")])])]),e("h2",{attrs:{id:"文档注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文档注释"}},[t._v("#")]),t._v(" 文档注释")]),t._v(" "),e("p",[t._v("所有顶层，且会导出的命名，都应该具有文档注释。不常见的包内私有函数和类型也应该写好文档注释。")]),t._v(" "),e("h2",{attrs:{id:"构造函数名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数名"}},[t._v("#")]),t._v(" 构造函数名")]),t._v(" "),e("p",[t._v("如果ring包里有一个类型Ring。通常情况，类型的构造函数会被命名为New+类型名：NewRing()。")]),t._v(" "),e("p",[t._v("但在另一种特殊情况下：Ring是ring包导出的唯一类型。并且包名也为ring，那么构造函数可以直接命名为New。用ring.New()来使用构造函数。")]),t._v(" "),e("h2",{attrs:{id:"文件名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件名"}},[t._v("#")]),t._v(" 文件名")]),t._v(" "),e("p",[t._v("文件名的命名遵循"),e("strong",[t._v("和包名同样")]),t._v(" 的规范。但又有下列特殊情况。")]),t._v(" "),e("ol",[e("li",[t._v("文件名由"),e("code",[t._v(".")]),t._v("或者"),e("code",[t._v("_")]),t._v("开头的话会自动被go tool忽略。")]),t._v(" "),e("li",[t._v("文件名以"),e("code",[t._v("_test.go")]),t._v("结束只会被"),e("code",[t._v("go test")]),t._v("工具编译。")]),t._v(" "),e("li",[t._v("文件名带有os和处理器架构名只会为指定平台编译。例如name_linux.go只会为linux上构建，name_amd64.go只会为amd64架构的处理器上构建。文件顶部的构建约束注释作用相同。")])]),t._v(" "),e("h2",{attrs:{id:"变量名与常量名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量名与常量名"}},[t._v("#")]),t._v(" 变量名与常量名")]),t._v(" "),e("p",[t._v("基本守则：变量的命名使用的越广，其名称就越应该清晰具体而有描述性。")]),t._v(" "),e("p",[t._v("在go中，对"),e("strong",[t._v("作用域有限的局部变量")]),t._v(" 来说，变量应该短而不是长。。例如使用"),e("code",[t._v("c")]),t._v("来指代"),e("code",[t._v("lineCounter")]),t._v("，用"),e("code",[t._v("i")]),t._v("来指代"),e("code",[t._v("sliceIndex")]),t._v("。循环索引或是reader之类的常见变量也可以是单个字母（i，r）。")]),t._v(" "),e("p",[t._v("不常见/全局的变量需要更具描述性的名称。")]),t._v(" "),e("p",[e("strong",[t._v("变量使用小写字母驼峰命名。常量使用大写字母驼峰命名")]),t._v(" 。如mixedCaps和MixedCaps。")]),t._v(" "),e("p",[t._v("变量和常量均不推荐使用下划线来链接多个单词。")]),t._v(" "),e("h2",{attrs:{id:"getter和setter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getter和setter"}},[t._v("#")]),t._v(" Getter和Setter")]),t._v(" "),e("p",[t._v("Go语言没有内建的Getter和Setter支持（不像kotlin）。在go中自己按需实现getter和setter是通用的做法。但是go中用GetXxxx作为getter名称并不符合规范。")]),t._v(" "),e("p",[t._v("如果有一个名为owner（小写，未导出）的字段，那么getter方法应称为Owner（）（大写，导出），而不是GetOwner。而setter函数，命名为SetOwner。")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[t._v("owner "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" obj"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Owner")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" owner "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" user "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    obj"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SetOwner")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("user"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"接口命名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口命名"}},[t._v("#")]),t._v(" 接口命名")]),t._v(" "),e("p",[t._v("按照官方规范，单个方法的接口的命名，是在其方法名后，加上"),e("code",[t._v("er")]),t._v("后缀，或者相似的修饰名的"),e("strong",[t._v("名词")]),t._v(" 。例如：Reader, Writer, Formatter, CloseNotifier。")]),t._v(" "),e("p",[t._v("而接口中的方法命名，若标准库中也具有同名方法，例如"),e("code",[t._v("Read, Write, Close, Flush, String")]),t._v("等词，那么如果接口的方法签名与标准库中不同，按照规范，不应该使用相同的名字。相反，如果接口的方法与熟知类型上的方法签名相同，则可以使用相同的名字。例如一个字符转换方法命名为"),e("code",[t._v("String")]),t._v("而不是"),e("code",[t._v("ToString")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"接收者命名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收者命名"}},[t._v("#")]),t._v(" 接收者命名")]),t._v(" "),e("p",[t._v("方法接受者的命名应该反映其身份。"),e("strong",[t._v("通常使用一个或两个字母的类型名缩写")]),t._v(' 就足够了。例如对Client类型使用"c"或"ci"做为接受者命名。但也要保持一致性，如果已经使用"c"作为接受者的名字，不要再在另一个方法中命名为"ci"。')]),t._v(" "),e("p",[t._v('不要使用一些其他oop语言中具有特殊含义的通用命名，例如"me"，"this","self"。')]),t._v(" "),e("h2",{attrs:{id:"声明空切片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#声明空切片"}},[t._v("#")]),t._v(" 声明空切片")]),t._v(" "),e("p",[t._v("当声明空切片时：")]),t._v(" "),e("p",[t._v("最好使用：")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" t "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n")])])]),e("p",[t._v("而不是：")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[t._v("t "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("前者声明了一个值为nil的切片，而后者值为非nil但长度为0。这两者功能相同，它们的len和cap均为0，但是nil切片是首选。")]),t._v(" "),e("h2",{attrs:{id:"不要使用painc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不要使用painc"}},[t._v("#")]),t._v(" 不要使用Painc")]),t._v(" "),e("p",[t._v("对普通错误，不要使用panic。使用error和多返回值。")]),t._v(" "),e("h2",{attrs:{id:"错误处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[t._v("#")]),t._v(" 错误处理")]),t._v(" "),e("p",[t._v("不要使用"),e("code",[t._v("_")]),t._v("丢弃错误。如果函数返回错误，请检查它以确保函数成功。处理错误，将其返回，或者在真正异常的情况下使用panic。")]),t._v(" "),e("h2",{attrs:{id:"错误字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误字符串"}},[t._v("#")]),t._v(" 错误字符串")]),t._v(" "),e("p",[t._v("错误字符串不应该应该是大写（除非以专有名词或缩写开头），或者以标点符号结束。 也就是说，使用"),e("code",[t._v('fmt.Errorf("something bad")')]),t._v("而不是"),e("code",[t._v('fmt.Errorf("Something bad")')]),t._v("。所以"),e("code",[t._v('log.Printf("Reading %s: %v", filename, err)')]),t._v("不会中间突然出一个大写字母。")]),t._v(" "),e("p",[t._v("但这不适用于日志，它一般是默认从新行打印。不会在其他消息中合并。")])])}),[],!1,null,null,null);a.default=r.exports}}]);