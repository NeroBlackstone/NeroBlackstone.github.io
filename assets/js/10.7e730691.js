(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{356:function(a,t,s){a.exports=s.p+"assets/img/jvm.352980fe.png"},357:function(a,t,s){a.exports=s.p+"assets/img/ClassLoader.75a3b54c.png"},407:function(a,t,s){"use strict";s.r(t);var n=s(14),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"jvm笔记"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jvm笔记"}},[a._v("#")]),a._v(" jvm笔记")]),a._v(" "),n("p",[a._v("jvm运行在操作系统上，它与硬件没有直接交互。")]),a._v(" "),n("p",[a._v("java中负责对字节代码解释执行的是虚拟机。")]),a._v(" "),n("p",[a._v("体系结构：")]),a._v(" "),n("p",[n("img",{attrs:{src:s(356),alt:"JVM"}})]),a._v(" "),n("h2",{attrs:{id:"类加载器-class-loader"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类加载器-class-loader"}},[a._v("#")]),a._v(" 类加载器/Class Loader")]),a._v(" "),n("p",[a._v("负责加载class文件，class文件在文件开头有特定的文件标示。并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。")]),a._v(" "),n("p",[n("img",{attrs:{src:s(357),alt:"ClassLoader"}})]),a._v(" "),n("h3",{attrs:{id:"虚拟机自带的加载器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机自带的加载器"}},[a._v("#")]),a._v(" 虚拟机自带的加载器")]),a._v(" "),n("ul",[n("li",[a._v("启动类加载器：BootstrapClassLoader （cpp实现）")]),a._v(" "),n("li",[a._v("平台类加载器：PlatformClassLoader （java实现）")]),a._v(" "),n("li",[a._v("应用类加载器：AppClassLoader （java实现，也叫做“系统类加载器”）")])]),a._v(" "),n("p",[a._v("启动类加载器，负责加载JVM虚拟机运行时所需的基本系统级别的类，如java.lang.String, java.lang.Object等等。启动类加载器无法通过"),n("code",[a._v("any.javaClass.classLoader")]),a._v("的方式取得。（因为它不是java实现的）")]),a._v(" "),n("p",[a._v("平台类加载器之前叫Extension Class Loader，但是java 9 之后为了支持模块系统，扩展机制被删除。")]),a._v(" "),n("p",[a._v("在java 9 之后，运行下列代码：")]),a._v(" "),n("div",{staticClass:"language-kotlin extra-class"},[n("pre",{pre:!0,attrs:{class:"language-kotlin"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" MyClass\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("fun")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("val")]),a._v(" myClass"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("MyClass")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("myClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("javaClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("classLoader"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("myClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("javaClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("classLoader"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("parent"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("myClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("javaClass"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("classLoader"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("parent"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("parent"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),n("p",[a._v("会打印:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("jdk.internal.loader.ClassLoaders$AppClassLoader@42a57993\njdk.internal.loader.ClassLoaders$PlatformClassLoader@eed1f14\nnull\n")])])]),n("h4",{attrs:{id:"双亲委派"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派"}},[a._v("#")]),a._v(" 双亲委派")]),a._v(" "),n("p",[a._v("双亲委派模型工作过程：一个类加载器收到类加载的请求，它首先会把这个请求委派给父类加载器去完成，层层上升，只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。")]),a._v(" "),n("p",[a._v("要注意的是父加载器和子加载器的关系不是继承关系而是组合关系。子加载器中有一个私有属性 parent 指向父加载器。")]),a._v(" "),n("h4",{attrs:{id:"沙箱机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#沙箱机制"}},[a._v("#")]),a._v(" 沙箱机制")]),a._v(" "),n("p",[a._v("沙箱安全机制是由基于双亲委派机制上，采取的一种JVM的自我保护机制,假设自己写一个java.lang.String 的类,在类中自定义方法，由于双亲委派机制的原理,此请求会先交给Bootstrap试图进行加载,但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类,有则优先加载rt.jar包中的类,没有自定义方法会报错，因此就保证了java的运行机制不会被破坏。")]),a._v(" "),n("h3",{attrs:{id:"用户自定义的加载器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用户自定义的加载器"}},[a._v("#")]),a._v(" 用户自定义的加载器")]),a._v(" "),n("p",[a._v("java.lang.ClassLoader的子类，用户可以自定义类的加载方式。")]),a._v(" "),n("h2",{attrs:{id:"执行引擎-execution-engine"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎-execution-engine"}},[a._v("#")]),a._v(" 执行引擎 / Execution Engine")]),a._v(" "),n("p",[a._v("Execution Engine负责解释命令，提交给操作系统执行。")]),a._v(" "),n("h2",{attrs:{id:"本地接口-java-native-interface-jni"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#本地接口-java-native-interface-jni"}},[a._v("#")]),a._v(" 本地接口 / java native interface / JNI")]),a._v(" "),n("p",[a._v("用于调用c/cpp方法")]),a._v(" "),n("h2",{attrs:{id:"本地方法栈-native-method-stack"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈-native-method-stack"}},[a._v("#")]),a._v(" 本地方法栈 / Native Method Stack")]),a._v(" "),n("p",[a._v("Native Method Stack中登记native method，Execution Engine执行时加载本地方法库。")]),a._v(" "),n("h2",{attrs:{id:"程序计数寄存器-program-counter-register"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#程序计数寄存器-program-counter-register"}},[a._v("#")]),a._v(" 程序计数寄存器 / Program Counter Register")]),a._v(" "),n("p",[a._v("每个线程都有一个程序计数器。是线程私有的，就是一个指针，指向方法区的方法字节码（用来存储指向下一条指令的地址），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。")]),a._v(" "),n("h2",{attrs:{id:"方法区-method-area"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法区-method-area"}},[a._v("#")]),a._v(" 方法区 / Method Area")]),a._v(" "),n("p",[a._v("方法区被所有线程共享，所有字段和方法字节码，以及一些特定的方法如构造函数，接口也在此定义。所有定义的方法的信息都保存在该区域，"),n("strong",[a._v("此区属于共享空间")]),a._v("。")]),a._v(" "),n("p",[a._v("静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存在方法区中。")]),a._v(" "),n("p",[a._v("但是实例变量存在堆内存中，和方法区无关。")])])}),[],!1,null,null,null);t.default=e.exports}}]);