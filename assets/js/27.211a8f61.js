(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{386:function(t,a,s){"use strict";s.r(a);var n=s(14),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"java字符串池，你懂吗？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java字符串池，你懂吗？"}},[t._v("#")]),t._v(" Java字符串池，你懂吗？")]),t._v(" "),s("p",[t._v("String应该是我们在java里用过最多的类了。在这篇文章中，将讨论java的字符串池(String Pool)————"),s("strong",[t._v("这是一块特殊的内存区域，JVM用其存储字符串。")])]),t._v(" "),s("h2",{attrs:{id:"字符串驻留-string-interning"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串驻留-string-interning"}},[t._v("#")]),t._v(" 字符串驻留(String Interning)")]),t._v(" "),s("p",[t._v("由于字符串在java中的不变性，JVM可以通过"),s("strong",[t._v("在池中仅存储一份每个字符串的拷贝")]),t._v(" 来优化内存分配。这个过程就叫做"),s("em",[t._v("驻留(literning)")]),t._v(" 。")]),t._v(" "),s("p",[t._v("当创建并且给一个"),s("em",[t._v("String")]),t._v(" 变量赋值时，JVM会在池里搜索等值的"),s("em",[t._v("String")]),t._v(" 。")]),t._v(" "),s("p",[s("strong",[t._v("如果找到，Java编译器将直接返回到这个内存地址的引用，而不再分配额外的内存。")]),t._v(" 如果未找到，字符串将会填加到池中，然后返回它的引用。")]),t._v(" "),s("p",[t._v("写一段kotlin代码验证一下：")]),t._v(" "),s("blockquote",[s("p",[t._v("要使用assert函数必须打开JVM的"),s("code",[t._v("-ea")]),t._v("选项")])]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"NeroBlackstone"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"NeroBlackstone"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("assert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("constantString1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v("constantString2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("可以发现没有抛出"),s("code",[t._v("java.lang.AssertionError")]),t._v("异常，说明指向的是同一地址。")]),t._v(" "),s("h2",{attrs:{id:"使用构造函数分配字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用构造函数分配字符串"}},[t._v("#")]),t._v(" 使用构造函数分配字符串")]),t._v(" "),s("p",[t._v("当使用构造函数创建字符串时，编译器将创建新的对象，并且将其存储到JVM的堆中。每个通过构造函数创建的字符串都会指向不同的内存区域，故有不同的地址。")]),t._v(" "),s("p",[t._v("看一下和上面有和不同：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ABC"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" charArray"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("charArrayOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'A'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'B'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'C'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("charArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("assert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("constantString1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v("constantString2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这次抛出了"),s("code",[t._v("java.lang.AssertionError")]),t._v("异常。")]),t._v(" "),s("h2",{attrs:{id:"字符串字面量和字符串对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串字面量和字符串对象"}},[t._v("#")]),t._v(" 字符串字面量和字符串对象")]),t._v(" "),s("p",[s("strong",[t._v("当我们使用构造函数创建字符串对象时，它总是要在堆中创建新对象。而与之相对，如果直接用字符串字面量创建一个对象，如果其在字符串池中已经存在，会直接从池中返回。")]),t._v(" 否则将创建一个新的字符串对象，并且放入字符串池以备将来使用。")]),t._v(" "),s("p",[t._v("从顶层上看，都只是字符串对象，主要的区别在构造函数总是创建一个新对象，而使用字面量创建字符串，会优先使用驻留的对象。")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" charArray"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("charArrayOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'A'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'B'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'C'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("charArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("charArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("assert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("constantString1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v("constantString2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("抛出了"),s("code",[t._v("java.lang.AssertionError")]),t._v("异常，可以看出使用构造函数的话会是两个不同的地址。")]),t._v(" "),s("p",[s("strong",[t._v("一般来说应尽可能使用字面量的创建方法。")]),t._v(" 它更加易于阅读并且让编译器更容易优化代码。")]),t._v(" "),s("h2",{attrs:{id:"手动驻留"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手动驻留"}},[t._v("#")]),t._v(" 手动驻留")]),t._v(" "),s("p",[t._v("其实我们可以通过在字符串对象上调用intern()函数手动将其驻留到池中。手动驻留字符串将会把它的引用存到池中，如果再需要JVM会返回这个引用。")]),t._v(" "),s("p",[t._v("比如像这样：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" charArray"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("charArrayOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'A'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'B'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'C'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("charArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" constantString2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" constantString1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("intern")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("assert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("constantString1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v("constantString2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("并不丢出"),s("code",[t._v("java.lang.AssertionError")]),t._v("异常,地址相等。")]),t._v(" "),s("h2",{attrs:{id:"java9新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java9新特性"}},[t._v("#")]),t._v(" java9新特性")]),t._v(" "),s("p",[t._v("java8时代，字符串在底层表示为字符串数组"),s("em",[t._v("char[]")]),t._v("，使用"),s("em",[t._v("UTF-16")]),t._v("编码，每个字符占用两个字节。")]),t._v(" "),s("p",[t._v("到了java9以后提供了一种新的表示方法，叫做"),s("em",[t._v("紧凑字符串(Compact Strings)")]),t._v(" 。这种新格式将根据存储内容，在"),s("em",[t._v("char[]")]),t._v(" 和 "),s("em",[t._v("byte[]")]),t._v(" 间选择正确的编码。")]),t._v(" "),s("p",[t._v("由于新的紧凑字符串只在需要时才使用"),s("em",[t._v("UTF-16")]),t._v(" ，因此堆内存的大小将会显著降低，也意味着GC开销会更小。")]),t._v(" "),s("p",[t._v("这是一个默认启用并实现的功能，你无需任何调整就能享受到新的优化。")])])}),[],!1,null,null,null);a.default=r.exports}}]);