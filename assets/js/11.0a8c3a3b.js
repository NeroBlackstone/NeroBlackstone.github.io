(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{351:function(t,a,v){t.exports=v.p+"assets/img/Stack-Memory-vs-Heap-Space-in-Java.79cd68dc.jpg"},385:function(t,a,v){"use strict";v.r(a);var s=v(14),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"jvm中的堆和栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm中的堆和栈"}},[t._v("#")]),t._v(" JVM中的堆和栈")]),t._v(" "),s("p",[t._v("为了让程序可以以最佳的状态运行，java把内存分为了堆和栈。"),s("strong",[t._v("每当我们声明新的对象和变量，调用新的方法，声明字符串或执行更多此类相似的操作，JVM都会从堆或栈中为这些操作分配空间。")])]),t._v(" "),s("p",[t._v("本文将讨论这两个内存模型。我将会列举堆和栈的几个关键的不同，以及阐述它们是如何存储在物理内存中的，还有它们提供给我们的一些特性，何时去使用它们。")]),t._v(" "),s("h2",{attrs:{id:"java中的栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java中的栈"}},[t._v("#")]),t._v(" java中的栈")]),t._v(" "),s("p",[s("strong",[t._v("java中的栈被用于静态内存分配和执行线程。")]),t._v(" 它包含函数中的原始类型值，和函数中的引用，这些引用指向的对象存储在堆中。")]),t._v(" "),s("p",[t._v("访问栈中内存需要按照后进先出的顺序。每当调用一个新方法时，栈顶就会创建一个新的区块，这个区块包含了和这个函数有关的一些特定的值，例如原始类型变量和对象的引用。")]),t._v(" "),s("p",[t._v("该方法执行完毕后，将刷新相应的堆帧，数据回流到所调用方法中，该区块被清空，为下一个要执行的函数腾出空间。")]),t._v(" "),s("h3",{attrs:{id:"栈的关键特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈的关键特性"}},[t._v("#")]),t._v(" 栈的关键特性")]),t._v(" "),s("p",[t._v("除了上文讨论的内容，栈还有如下特性：")]),t._v(" "),s("ul",[s("li",[t._v("随着新方法的调用和返回，栈的大小会自动增长和收缩。")]),t._v(" "),s("li",[t._v("栈中的变量仅在创建这些变量的方法运行时存在。")]),t._v(" "),s("li",[t._v("方法执行完毕后栈内空间会自动分配和释放。")]),t._v(" "),s("li",[t._v("如果栈内存已满，java会丢出"),s("em",[t._v("java.lang.StackOverFlowError")]),t._v("异常。")]),t._v(" "),s("li",[t._v("相比与访问堆内存，访问栈内存更快。")]),t._v(" "),s("li",[t._v("栈内存是线程安全的，因为每个线程只操作自己的栈。")])]),t._v(" "),s("h2",{attrs:{id:"java中的堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java中的堆"}},[t._v("#")]),t._v(" java中的堆")]),t._v(" "),s("p",[s("strong",[t._v("java中的堆空间被用于java对象和JRE类在运行时的动态内存分配。")]),t._v(" 新的对象总是在堆中创建，并且该对象的引用被存储在栈中。")]),t._v(" "),s("p",[t._v("这些对象具有全局访问属性，可以从程序的任何位置被访问。")]),t._v(" "),s("p",[t._v("在之前的JVM实现中堆中会被细分为世代以便于GC回收内存，但是新的ZGC已经不通过世代来回收内存，每次GC都会标记整个堆空间。故有关世代的内容本文不再阐述。")]),t._v(" "),s("h3",{attrs:{id:"堆的关键特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的关键特性"}},[t._v("#")]),t._v(" 堆的关键特性")]),t._v(" "),s("p",[t._v("除了上文提到的内容，堆还有如下特性：")]),t._v(" "),s("ul",[s("li",[t._v("如果堆已满，会抛出"),s("em",[t._v("java.lang.OutOfMemoryError")]),t._v("异常")]),t._v(" "),s("li",[t._v("对该堆内存的访问会比栈内存慢")]),t._v(" "),s("li",[t._v("与栈相比，堆空间不会自动释放。它需要GC去清空无用的对象，以保持内存使用的效率")]),t._v(" "),s("li",[t._v("与栈不同，堆不是线程安全的，并且需要被正确的同步代码保护")])]),t._v(" "),s("h2",{attrs:{id:"代码示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码示例"}},[t._v("#")]),t._v(" 代码示例")]),t._v(" "),s("p",[t._v("基于上文的知识点，来分析一段简单的kotlin代码吧！")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pid"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Int "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" String"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("23")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" pName "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Jon"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Person"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n    p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ol",[s("li",[t._v("进入"),s("em",[t._v("main()")]),t._v(" 方法后，栈会创建空间来存放原始类型和对象的引用。")])]),t._v(" "),s("ul",[s("li",[t._v("整数的原始类型值"),s("em",[t._v("id")]),t._v(" 会被直接存到栈内。")]),t._v(" "),s("li",[s("em",[t._v("Person")]),t._v(" 类型的变量"),s("em",[t._v("p")]),t._v(" 的引用也会被存于栈空间，该引用会指向堆中的实际对象")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("从"),s("em",[t._v("main()")]),t._v(" 中调用带参构造函数"),s("em",[t._v("Person(Int,String?)")]),t._v(" 将会在栈顶分配内存。用于存储：")])]),t._v(" "),s("ul",[s("li",[s("em",[t._v("this")]),t._v(" 对象的引用")]),t._v(" "),s("li",[t._v("原始类型值"),s("em",[t._v("id")])]),t._v(" "),s("li",[t._v("参数"),s("em",[t._v("personName")]),t._v("的"),s("em",[t._v("String?")]),t._v(" 类型的变量的引用，将会指向堆内存中的字符串池中的实际字符串")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("此默认构造函数将进一步调用隐式的"),s("em",[t._v("setName（）")]),t._v(" 方法，栈顶也会为这个方法分配内存，然后以上文提到的方式再一次存储变量。")]),t._v(" "),s("li",[t._v("对于新创建的"),s("em",[t._v("Person")]),t._v(" 类型的对象"),s("em",[t._v("p")]),t._v(" ，所有的实例变量将存到堆内存中。")])]),t._v(" "),s("p",[t._v("整个分配如下图所示:")]),t._v(" "),s("p",[s("img",{attrs:{src:v(351),alt:"Stack-Memory-vs-Heap-Space-in-Java"}})]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("参数")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("栈")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("堆")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("应用场景")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("栈在局部使用，在线程执行期间一次只访问一个栈")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("整个程序在运行时都会使用堆空间")])]),t._v(" "),s("tr",[s("td",[t._v("容量大小")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("根据os不同，栈有大小限制，通常比堆低")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("堆没有大小限制")])]),t._v(" "),s("tr",[s("td",[t._v("存储")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("只存储原始类型变量和堆中对象的引用")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("存储所有新创建的对象")])]),t._v(" "),s("tr",[s("td",[t._v("生命周期")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("栈只存在于当前方法运行的时候")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("只要程序在运行，堆空间就存在")])]),t._v(" "),s("tr",[s("td",[t._v("分配效率")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("相较于堆分配较快")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("相较与栈分配较慢")])]),t._v(" "),s("tr",[s("td",[t._v("分配/释放")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("当方法被调用时和返回时，内存自动分配和释放")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("当新对象被创建时，分配堆空间，当对象不再被引用时，GC释放空间")])])])])])}),[],!1,null,null,null);a.default=e.exports}}]);